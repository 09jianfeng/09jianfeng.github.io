<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ReactiveCocoa文档 | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ReactiveCocoa文档</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ReactiveCocoa文档</h1><div class="post-meta">Sep 8, 2016</div><div class="post-content"><h1 id="ReactiveCocoa-github上已经去掉了相关文档，我这里存档一份"><a href="#ReactiveCocoa-github上已经去掉了相关文档，我这里存档一份" class="headerlink" title="ReactiveCocoa github上已经去掉了相关文档，我这里存档一份"></a>ReactiveCocoa github上已经去掉了相关文档，我这里存档一份</h1><p><em>NOTE: This is legacy introduction to the Objective-C ReactiveCocoa. For the<br>updated version that uses Swift please see the main <a href="../../README.md">README</a></em></p>
<p>ReactiveCocoa (RAC) is an Objective-C framework inspired by <a href="http://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener">Functional Reactive<br>Programming</a>. It provides APIs for <strong>composing and transforming streams of<br>values</strong>.</p>
<p>If you’re already familiar with functional reactive programming or know the basic<br>premise of ReactiveCocoa, check out the other documentation in this folder for a<br>framework overview and more in-depth information about how it all works in practice.</p>
<h2 id="New-to-ReactiveCocoa"><a href="#New-to-ReactiveCocoa" class="headerlink" title="New to ReactiveCocoa?"></a>New to ReactiveCocoa?</h2><p>ReactiveCocoa is documented like crazy, and there’s a wealth of introductory<br>material available to explain what RAC is and how you can use it.</p>
<p>If you want to learn more, we recommend these resources, roughly in order:</p>
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#when-to-use-reactivecocoa">When to use ReactiveCocoa</a></li>
<li><a href="FrameworkOverview.md">Framework Overview</a></li>
<li><a href="BasicOperators.md">Basic Operators</a></li>
<li><a href="../../ReactiveCocoa/Objective-C">Header documentation</a></li>
<li>Previously answered <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/wiki" target="_blank" rel="noopener">Stack Overflow</a><br>questions and <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues?labels=question&amp;state=closed" target="_blank" rel="noopener">GitHub issues</a></li>
<li>The rest of this folder</li>
<li><a href="https://leanpub.com/iosfrp/" target="_blank" rel="noopener">Functional Reactive Programming on iOS</a><br>(eBook)</li>
</ol>
<p>If you have any further questions, please feel free to <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/new" target="_blank" rel="noopener">file an issue</a>. </p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>ReactiveCocoa is inspired by <a href="http://blog.maybeapps.com/post/42894317939/input-and-output" target="_blank" rel="noopener">functional reactive<br>programming</a>.<br>Rather than using mutable variables which are replaced and modified in-place,<br>RAC provides signals (represented by <code>RACSignal</code>) that capture present and<br>future values.</p>
<p>By chaining, combining, and reacting to signals, software can be written<br>declaratively, without the need for code that continually observes and updates<br>values.</p>
<p>For example, a text field can be bound to the latest time, even as it changes,<br>instead of using additional code that watches the clock and updates the<br>text field every second.  It works much like KVO, but with blocks instead of<br>overriding <code>-observeValueForKeyPath:ofObject:change:context:</code>.</p>
<p>Signals can also represent asynchronous operations, much like <a href="http://en.wikipedia.org/wiki/Futures_and_promises" target="_blank" rel="noopener">futures and<br>promises</a>. This greatly simplifies asynchronous software, including networking<br>code.</p>
<p>One of the major advantages of RAC is that it provides a single, unified<br>approach to dealing with asynchronous behaviors, including delegate methods,<br>callback blocks, target-action mechanisms, notifications, and KVO.</p>
<p>Here’s a simple example:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// When self.username changes, logs the new name to the console.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RACObserve(self, username) creates a new RACSignal that sends the current</span></span><br><span class="line"><span class="comment">// value of self.username, then the new value whenever it changes.</span></span><br><span class="line"><span class="comment">// -subscribeNext: will execute the block whenever the signal sends a value.</span></span><br><span class="line">[RACObserve(<span class="keyword">self</span>, username) subscribeNext:^(<span class="built_in">NSString</span> *newName) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, newName);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>But unlike KVO notifications, signals can be chained together and operated on:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Only logs names that starts with "j".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// -filter returns a new RACSignal that only sends a new value when its block</span></span><br><span class="line"><span class="comment">// returns YES.</span></span><br><span class="line">[[RACObserve(<span class="keyword">self</span>, username)</span><br><span class="line">	filter:^(<span class="built_in">NSString</span> *newName) &#123;</span><br><span class="line">		<span class="keyword">return</span> [newName hasPrefix:<span class="string">@"j"</span>];</span><br><span class="line">	&#125;]</span><br><span class="line">	subscribeNext:^(<span class="built_in">NSString</span> *newName) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, newName);</span><br><span class="line">	&#125;];</span><br></pre></td></tr></table></figure>
<p>Signals can also be used to derive state. Instead of observing properties and<br>setting other properties in response to the new values, RAC makes it possible to<br>express properties in terms of signals and operations:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a one-way binding so that self.createEnabled will be</span></span><br><span class="line"><span class="comment">// true whenever self.password and self.passwordConfirmation</span></span><br><span class="line"><span class="comment">// are equal.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RAC() is a macro that makes the binding look nicer.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// +combineLatest:reduce: takes an array of signals, executes the block with the</span></span><br><span class="line"><span class="comment">// latest value from each signal whenever any of them changes, and returns a new</span></span><br><span class="line"><span class="comment">// RACSignal that sends the return value of that block as values.</span></span><br><span class="line">RAC(<span class="keyword">self</span>, createEnabled) = [RACSignal </span><br><span class="line">	combineLatest:@[ RACObserve(<span class="keyword">self</span>, password), RACObserve(<span class="keyword">self</span>, passwordConfirmation) ] </span><br><span class="line">	reduce:^(<span class="built_in">NSString</span> *password, <span class="built_in">NSString</span> *passwordConfirm) &#123;</span><br><span class="line">		<span class="keyword">return</span> @([passwordConfirm isEqualToString:password]);</span><br><span class="line">	&#125;];</span><br></pre></td></tr></table></figure>
<p>Signals can be built on any stream of values over time, not just KVO. For<br>example, they can also represent button presses:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Logs a message whenever the button is pressed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RACCommand creates signals to represent UI actions. Each signal can</span></span><br><span class="line"><span class="comment">// represent a button press, for example, and have additional work associated</span></span><br><span class="line"><span class="comment">// with it.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// -rac_command is an addition to NSButton. The button will send itself on that</span></span><br><span class="line"><span class="comment">// command whenever it's pressed.</span></span><br><span class="line"><span class="keyword">self</span>.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^(<span class="keyword">id</span> _) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"button was pressed!"</span>);</span><br><span class="line">	<span class="keyword">return</span> [RACSignal empty];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>Or asynchronous network operations:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hooks up a "Log in" button to log in over the network.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This block will be run whenever the login command is executed, starting</span></span><br><span class="line"><span class="comment">// the login process.</span></span><br><span class="line"><span class="keyword">self</span>.loginCommand = [[RACCommand alloc] initWithSignalBlock:^(<span class="keyword">id</span> sender) &#123;</span><br><span class="line">	<span class="comment">// The hypothetical -logIn method returns a signal that sends a value when</span></span><br><span class="line">	<span class="comment">// the network request finishes.</span></span><br><span class="line">	<span class="keyword">return</span> [client logIn];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// -executionSignals returns a signal that includes the signals returned from</span></span><br><span class="line"><span class="comment">// the above block, one for each time the command is executed.</span></span><br><span class="line">[<span class="keyword">self</span>.loginCommand.executionSignals subscribeNext:^(RACSignal *loginSignal) &#123;</span><br><span class="line">	<span class="comment">// Log a message whenever we log in successfully.</span></span><br><span class="line">	[loginSignal subscribeCompleted:^&#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"Logged in successfully!"</span>);</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executes the login command when the button is pressed.</span></span><br><span class="line"><span class="keyword">self</span>.loginButton.rac_command = <span class="keyword">self</span>.loginCommand;</span><br></pre></td></tr></table></figure>
<p>Signals can also represent timers, other UI events, or anything else that<br>changes over time.</p>
<p>Using signals for asynchronous operations makes it possible to build up more<br>complex behavior by chaining and transforming those signals. Work can easily be<br>triggered after a group of operations completes:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Performs 2 network operations and logs a message to the console when they are</span></span><br><span class="line"><span class="comment">// both completed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +merge: takes an array of signals and returns a new RACSignal that passes</span></span><br><span class="line"><span class="comment">// through the values of all of the signals and completes when all of the</span></span><br><span class="line"><span class="comment">// signals complete.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// -subscribeCompleted: will execute the block when the signal completes.</span></span><br><span class="line">[[RACSignal </span><br><span class="line">	merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]] </span><br><span class="line">	subscribeCompleted:^&#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"They're both done!"</span>);</span><br><span class="line">	&#125;];</span><br></pre></td></tr></table></figure>
<p>Signals can be chained to sequentially execute asynchronous operations, instead<br>of nesting callbacks with blocks. This is similar to how <a href="http://en.wikipedia.org/wiki/Futures_and_promises" target="_blank" rel="noopener">futures and promises</a><br>are usually used:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Logs in the user, then loads any cached messages, then fetches the remaining</span></span><br><span class="line"><span class="comment">// messages from the server. After that's all done, logs a message to the</span></span><br><span class="line"><span class="comment">// console.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The hypothetical -logInUser methods returns a signal that completes after</span></span><br><span class="line"><span class="comment">// logging in.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// -flattenMap: will execute its block whenever the signal sends a value, and</span></span><br><span class="line"><span class="comment">// returns a new RACSignal that merges all of the signals returned from the block</span></span><br><span class="line"><span class="comment">// into a single signal.</span></span><br><span class="line">[[[[client </span><br><span class="line">	logInUser] </span><br><span class="line">	flattenMap:^(User *user) &#123;</span><br><span class="line">		<span class="comment">// Return a signal that loads cached messages for the user.</span></span><br><span class="line">		<span class="keyword">return</span> [client loadCachedMessagesForUser:user];</span><br><span class="line">	&#125;]</span><br><span class="line">	flattenMap:^(<span class="built_in">NSArray</span> *messages) &#123;</span><br><span class="line">		<span class="comment">// Return a signal that fetches any remaining messages.</span></span><br><span class="line">		<span class="keyword">return</span> [client fetchMessagesAfterMessage:messages.lastObject];</span><br><span class="line">	&#125;]</span><br><span class="line">	subscribeNext:^(<span class="built_in">NSArray</span> *newMessages) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"New messages: %@"</span>, newMessages);</span><br><span class="line">	&#125; completed:^&#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"Fetched all messages."</span>);</span><br><span class="line">	&#125;];</span><br></pre></td></tr></table></figure>
<p>RAC even makes it easy to bind to the result of an asynchronous operation:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a one-way binding so that self.imageView.image will be set as the user's</span></span><br><span class="line"><span class="comment">// avatar as soon as it's downloaded.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The hypothetical -fetchUserWithUsername: method returns a signal which sends</span></span><br><span class="line"><span class="comment">// the user.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// -deliverOn: creates new signals that will do their work on other queues. In</span></span><br><span class="line"><span class="comment">// this example, it's used to move work to a background queue and then back to the main thread.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// -map: calls its block with each user that's fetched and returns a new</span></span><br><span class="line"><span class="comment">// RACSignal that sends values returned from the block.</span></span><br><span class="line">RAC(<span class="keyword">self</span>.imageView, image) = [[[[client </span><br><span class="line">	fetchUserWithUsername:<span class="string">@"joshaber"</span>]</span><br><span class="line">	deliverOn:[RACScheduler scheduler]]</span><br><span class="line">	map:^(User *user) &#123;</span><br><span class="line">		<span class="comment">// Download the avatar (this is done on a background queue).</span></span><br><span class="line">		<span class="keyword">return</span> [[<span class="built_in">NSImage</span> alloc] initWithContentsOfURL:user.avatarURL];</span><br><span class="line">	&#125;]</span><br><span class="line">	<span class="comment">// Now the assignment will be done on the main thread.</span></span><br><span class="line">	deliverOn:RACScheduler.mainThreadScheduler];</span><br></pre></td></tr></table></figure>
<p>That demonstrates some of what RAC can do, but it doesn’t demonstrate why RAC is<br>so powerful. It’s hard to appreciate RAC from README-sized examples, but it<br>makes it possible to write code with less state, less boilerplate, better code<br>locality, and better expression of intent.</p>
<p>For more sample code, check out <a href="https://github.com/AshFurrow/C-41" target="_blank" rel="noopener">C-41</a> or <a href="https://github.com/jspahrsummers/GroceryList" target="_blank" rel="noopener">GroceryList</a>, which are real iOS<br>apps written using ReactiveCocoa. Additional information about RAC can be found<br>in this folder.</p>
<h2 id="When-to-use-ReactiveCocoa"><a href="#When-to-use-ReactiveCocoa" class="headerlink" title="When to use ReactiveCocoa"></a>When to use ReactiveCocoa</h2><p>Upon first glance, ReactiveCocoa is very abstract, and it can be difficult to<br>understand how to apply it to concrete problems.</p>
<p>Here are some of the use cases that RAC excels at.</p>
<h3 id="Handling-asynchronous-or-event-driven-data-sources"><a href="#Handling-asynchronous-or-event-driven-data-sources" class="headerlink" title="Handling asynchronous or event-driven data sources"></a>Handling asynchronous or event-driven data sources</h3><p>Much of Cocoa programming is focused on reacting to user events or changes in<br>application state. Code that deals with such events can quickly become very<br>complex and spaghetti-like, with lots of callbacks and state variables to handle<br>ordering issues.</p>
<p>Patterns that seem superficially different, like UI callbacks, network<br>responses, and KVO notifications, actually have a lot in common. <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a><br>unifies all these different APIs so that they can be composed together and<br>manipulated in the same way.</p>
<p>For example, the following code:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *ObservationContext = &amp;ObservationContext;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">	[LoginManager.sharedManager addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"loggingIn"</span> options:<span class="built_in">NSKeyValueObservingOptionInitial</span> context:&amp;ObservationContext];</span><br><span class="line">	[<span class="built_in">NSNotificationCenter</span>.defaultCenter addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(loggedOut:) name:UserDidLogOutNotification object:LoginManager.sharedManager];</span><br><span class="line"></span><br><span class="line">	[<span class="keyword">self</span>.usernameTextField addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(updateLogInButton) forControlEvents:<span class="built_in">UIControlEventEditingChanged</span>];</span><br><span class="line">	[<span class="keyword">self</span>.passwordTextField addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(updateLogInButton) forControlEvents:<span class="built_in">UIControlEventEditingChanged</span>];</span><br><span class="line">	[<span class="keyword">self</span>.logInButton addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(logInPressed:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">	[LoginManager.sharedManager removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"loggingIn"</span> context:ObservationContext];</span><br><span class="line">	[<span class="built_in">NSNotificationCenter</span>.defaultCenter removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)updateLogInButton &#123;</span><br><span class="line">	<span class="built_in">BOOL</span> textFieldsNonEmpty = <span class="keyword">self</span>.usernameTextField.text.length &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">self</span>.passwordTextField.text.length &gt; <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">BOOL</span> readyToLogIn = !LoginManager.sharedManager.isLoggingIn &amp;&amp; !<span class="keyword">self</span>.loggedIn;</span><br><span class="line">	<span class="keyword">self</span>.logInButton.enabled = textFieldsNonEmpty &amp;&amp; readyToLogIn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)logInPressed:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">	[[LoginManager sharedManager]</span><br><span class="line">		logInWithUsername:<span class="keyword">self</span>.usernameTextField.text</span><br><span class="line">		password:<span class="keyword">self</span>.passwordTextField.text</span><br><span class="line">		success:^&#123;</span><br><span class="line">			<span class="keyword">self</span>.loggedIn = <span class="literal">YES</span>;</span><br><span class="line">		&#125; failure:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">			[<span class="keyword">self</span> presentError:error];</span><br><span class="line">		&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)loggedOut:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">	<span class="keyword">self</span>.loggedIn = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">	<span class="keyword">if</span> (context == ObservationContext) &#123;</span><br><span class="line">		[<span class="keyword">self</span> updateLogInButton];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		[<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>… could be expressed in RAC like so:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">	@weakify(<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">	RAC(<span class="keyword">self</span>.logInButton, enabled) = [RACSignal</span><br><span class="line">		combineLatest:@[</span><br><span class="line">			<span class="keyword">self</span>.usernameTextField.rac_textSignal,</span><br><span class="line">			<span class="keyword">self</span>.passwordTextField.rac_textSignal,</span><br><span class="line">			RACObserve(LoginManager.sharedManager, loggingIn),</span><br><span class="line">			RACObserve(<span class="keyword">self</span>, loggedIn)</span><br><span class="line">		] reduce:^(<span class="built_in">NSString</span> *username, <span class="built_in">NSString</span> *password, <span class="built_in">NSNumber</span> *loggingIn, <span class="built_in">NSNumber</span> *loggedIn) &#123;</span><br><span class="line">			<span class="keyword">return</span> @(username.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span> &amp;&amp; !loggingIn.boolValue &amp;&amp; !loggedIn.boolValue);</span><br><span class="line">		&#125;];</span><br><span class="line"></span><br><span class="line">	[[<span class="keyword">self</span>.logInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="built_in">UIButton</span> *sender) &#123;</span><br><span class="line">		@strongify(<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">		RACSignal *loginSignal = [LoginManager.sharedManager</span><br><span class="line">			logInWithUsername:<span class="keyword">self</span>.usernameTextField.text</span><br><span class="line">			password:<span class="keyword">self</span>.passwordTextField.text];</span><br><span class="line"></span><br><span class="line">			[loginSignal subscribeError:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">				@strongify(<span class="keyword">self</span>);</span><br><span class="line">				[<span class="keyword">self</span> presentError:error];</span><br><span class="line">			&#125; completed:^&#123;</span><br><span class="line">				@strongify(<span class="keyword">self</span>);</span><br><span class="line">				<span class="keyword">self</span>.loggedIn = <span class="literal">YES</span>;</span><br><span class="line">			&#125;];</span><br><span class="line">	&#125;];</span><br><span class="line"></span><br><span class="line">	RAC(<span class="keyword">self</span>, loggedIn) = [[<span class="built_in">NSNotificationCenter</span>.defaultCenter</span><br><span class="line">		rac_addObserverForName:UserDidLogOutNotification object:<span class="literal">nil</span>]</span><br><span class="line">		mapReplace:@NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Chaining-dependent-operations"><a href="#Chaining-dependent-operations" class="headerlink" title="Chaining dependent operations"></a>Chaining dependent operations</h3><p>Dependencies are most often found in network requests, where a previous request<br>to the server needs to complete before the next one can be constructed, and so<br>on:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[client logInWithSuccess:^&#123;</span><br><span class="line">	[client loadCachedMessagesWithSuccess:^(<span class="built_in">NSArray</span> *messages) &#123;</span><br><span class="line">		[client fetchMessagesAfterMessage:messages.lastObject success:^(<span class="built_in">NSArray</span> *nextMessages) &#123;</span><br><span class="line">			<span class="built_in">NSLog</span>(<span class="string">@"Fetched all messages."</span>);</span><br><span class="line">		&#125; failure:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">			[<span class="keyword">self</span> presentError:error];</span><br><span class="line">		&#125;];</span><br><span class="line">	&#125; failure:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">		[<span class="keyword">self</span> presentError:error];</span><br><span class="line">	&#125;];</span><br><span class="line">&#125; failure:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">	[<span class="keyword">self</span> presentError:error];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>ReactiveCocoa makes this pattern particularly easy:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[[[client logIn]</span><br><span class="line">	then:^&#123;</span><br><span class="line">		<span class="keyword">return</span> [client loadCachedMessages];</span><br><span class="line">	&#125;]</span><br><span class="line">	flattenMap:^(<span class="built_in">NSArray</span> *messages) &#123;</span><br><span class="line">		<span class="keyword">return</span> [client fetchMessagesAfterMessage:messages.lastObject];</span><br><span class="line">	&#125;]</span><br><span class="line">	subscribeError:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">		[<span class="keyword">self</span> presentError:error];</span><br><span class="line">	&#125; completed:^&#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"Fetched all messages."</span>);</span><br><span class="line">	&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="Parallelizing-independent-work"><a href="#Parallelizing-independent-work" class="headerlink" title="Parallelizing independent work"></a>Parallelizing independent work</h3><p>Working with independent data sets in parallel and then combining them into<br>a final result is non-trivial in Cocoa, and often involves a lot of<br>synchronization:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSArray</span> *databaseObjects;</span><br><span class="line">__block <span class="built_in">NSArray</span> *fileContents;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">NSOperationQueue</span> *backgroundQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *databaseOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">	databaseObjects = [databaseClient fetchObjectsMatchingPredicate:predicate];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *filesOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">	<span class="built_in">NSMutableArray</span> *filesInProgress = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">NSString</span> *path <span class="keyword">in</span> files) &#123;</span><br><span class="line">		[filesInProgress addObject:[<span class="built_in">NSData</span> dataWithContentsOfFile:path]];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fileContents = [filesInProgress <span class="keyword">copy</span>];</span><br><span class="line">&#125;];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">NSBlockOperation</span> *finishOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">	[<span class="keyword">self</span> finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents];</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"Done processing"</span>);</span><br><span class="line">&#125;];</span><br><span class="line"> </span><br><span class="line">[finishOperation addDependency:databaseOperation];</span><br><span class="line">[finishOperation addDependency:filesOperation];</span><br><span class="line">[backgroundQueue addOperation:databaseOperation];</span><br><span class="line">[backgroundQueue addOperation:filesOperation];</span><br><span class="line">[backgroundQueue addOperation:finishOperation];</span><br></pre></td></tr></table></figure>
<p>The above code can be cleaned up and optimized by simply composing signals:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *databaseSignal = [[databaseClient</span><br><span class="line">	fetchObjectsMatchingPredicate:predicate]</span><br><span class="line">	subscribeOn:[RACScheduler scheduler]];</span><br><span class="line"></span><br><span class="line">RACSignal *fileSignal = [RACSignal startEagerlyWithScheduler:[RACScheduler scheduler] block:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">	<span class="built_in">NSMutableArray</span> *filesInProgress = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">NSString</span> *path <span class="keyword">in</span> files) &#123;</span><br><span class="line">		[filesInProgress addObject:[<span class="built_in">NSData</span> dataWithContentsOfFile:path]];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[subscriber sendNext:[filesInProgress <span class="keyword">copy</span>]];</span><br><span class="line">	[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[RACSignal</span><br><span class="line">	combineLatest:@[ databaseSignal, fileSignal ]</span><br><span class="line">	reduce:^ <span class="keyword">id</span> (<span class="built_in">NSArray</span> *databaseObjects, <span class="built_in">NSArray</span> *fileContents) &#123;</span><br><span class="line">		[<span class="keyword">self</span> finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">	&#125;]</span><br><span class="line">	subscribeCompleted:^&#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"Done processing"</span>);</span><br><span class="line">	&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="Simplifying-collection-transformations"><a href="#Simplifying-collection-transformations" class="headerlink" title="Simplifying collection transformations"></a>Simplifying collection transformations</h3><p>Higher-order functions like <code>map</code>, <code>filter</code>, <code>fold</code>/<code>reduce</code> are sorely missing<br>from Foundation, leading to loop-focused code like this:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *results = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *str <span class="keyword">in</span> strings) &#123;</span><br><span class="line">	<span class="keyword">if</span> (str.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NSString</span> *newString = [str stringByAppendingString:<span class="string">@"foobar"</span>];</span><br><span class="line">	[results addObject:newString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="../../ReactiveCocoa/Objective-C/RACSequence.h">RACSequence</a> allows any Cocoa collection to be manipulated in a uniform and<br>declarative way:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *results = [[strings.rac_sequence</span><br><span class="line">	filter:^ <span class="built_in">BOOL</span> (<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">		<span class="keyword">return</span> str.length &gt;= <span class="number">2</span>;</span><br><span class="line">	&#125;]</span><br><span class="line">	map:^(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">		<span class="keyword">return</span> [str stringByAppendingString:<span class="string">@"foobar"</span>];</span><br><span class="line">	&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="System-Requirements"><a href="#System-Requirements" class="headerlink" title="System Requirements"></a>System Requirements</h2><p>ReactiveCocoa supports OS X 10.8+ and iOS 8.0+.</p>
<h2 id="Importing-ReactiveCocoa"><a href="#Importing-ReactiveCocoa" class="headerlink" title="Importing ReactiveCocoa"></a>Importing ReactiveCocoa</h2><p>To add RAC to your application:</p>
<ol>
<li>Add the ReactiveCocoa repository as a submodule of your application’s<br>repository.</li>
<li>Run <code>script/bootstrap</code> from within the ReactiveCocoa folder.</li>
<li>Drag and drop <code>ReactiveCocoa.xcodeproj</code> into your<br>application’s Xcode project or workspace.</li>
<li>On the “Build Phases” tab of your application target, add RAC to the “Link<br>Binary With Libraries” phase.<ul>
<li><strong>On iOS</strong>, add <code>libReactiveCocoa-iOS.a</code>.</li>
<li><strong>On OS X</strong>, add <code>ReactiveCocoa.framework</code>. RAC must also be added to any<br>“Copy Frameworks” build phase. If you don’t already have one, simply add<br>a “Copy Files” build phase and target the “Frameworks” destination.</li>
</ul>
</li>
<li>Add <code>&quot;$(BUILD_ROOT)/../IntermediateBuildFilesPath/UninstalledProducts/include&quot;
$(inherited)</code> to the “Header Search Paths” build setting (this is only<br>necessary for archive builds, but it has no negative effect otherwise).</li>
<li><strong>For iOS targets</strong>, add <code>-ObjC</code> to the “Other Linker Flags” build setting.</li>
<li><strong>If you added RAC to a project (not a workspace)</strong>, you will also need to<br>add the appropriate RAC target to the “Target Dependencies” of your<br>application.</li>
</ol>
<p>If you would prefer to use <a href="http://cocoapods.org" target="_blank" rel="noopener">CocoaPods</a>, there are some<br><a href="https://github.com/CocoaPods/Specs/tree/master/Specs/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa<br>podspecs</a> that<br>have been generously contributed by third parties.</p>
<p>To see a project already set up with RAC, check out <a href="https://github.com/AshFurrow/C-41" target="_blank" rel="noopener">C-41</a> or <a href="https://github.com/jspahrsummers/GroceryList" target="_blank" rel="noopener">GroceryList</a>,<br>which are real iOS apps written using ReactiveCocoa.</p>
<h2 id="More-Info"><a href="#More-Info" class="headerlink" title="More Info"></a>More Info</h2><p>ReactiveCocoa is inspired by .NET’s <a href="http://msdn.microsoft.com/en-us/data/gg577609" target="_blank" rel="noopener">Reactive<br>Extensions</a> (Rx). Most of the<br>principles of Rx apply to RAC as well. There are some really good Rx resources<br>out there:</p>
<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/hh242985.aspx" target="_blank" rel="noopener">Reactive Extensions MSDN entry</a></li>
<li><a href="http://leecampbell.blogspot.com/2010/08/reactive-extensions-for-net.html" target="_blank" rel="noopener">Reactive Extensions for .NET Introduction</a></li>
<li><a href="http://channel9.msdn.com/tags/Rx/" target="_blank" rel="noopener">Rx - Channel 9 videos</a></li>
<li><a href="http://rxwiki.wikidot.com/" target="_blank" rel="noopener">Reactive Extensions wiki</a></li>
<li><a href="http://rxwiki.wikidot.com/101samples" target="_blank" rel="noopener">101 Rx Samples</a></li>
<li><a href="http://www.amazon.com/Programming-Reactive-Extensions-Jesse-Liberty/dp/1430237473" target="_blank" rel="noopener">Programming Reactive Extensions and LINQ</a></li>
</ul>
<p>RAC and Rx are both frameworks inspired by functional reactive programming. Here<br>are some resources related to FRP:</p>
<ul>
<li><a href="http://elm-lang.org/learn/What-is-FRP.elm" target="_blank" rel="noopener">What is FRP? - Elm Language</a></li>
<li><a href="http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631" target="_blank" rel="noopener">What is Functional Reactive Programming - Stack Overflow</a></li>
<li><a href="http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525" target="_blank" rel="noopener">Specification for a Functional Reactive Language - Stack Overflow</a></li>
<li><a href="http://elm-lang.org/learn/Escape-from-Callback-Hell.elm" target="_blank" rel="noopener">Escape from Callback Hell</a></li>
<li><a href="https://www.coursera.org/course/reactive" target="_blank" rel="noopener">Principles of Reactive Programming on Coursera</a></li>
</ul>
<h1 id="Basic-Operators"><a href="#Basic-Operators" class="headerlink" title="Basic Operators"></a>Basic Operators</h1><p>This document explains some of the most common operators used in ReactiveCocoa,<br>and includes examples demonstrating their use.</p>
<p>Operators that apply to <a href="FrameworkOverview.md#sequences">sequences</a> <em>and</em> <a href="FrameworkOverview.md#signals">signals</a> are<br>known as <a href="FrameworkOverview.md#streams">stream</a> operators.</p>
<p><strong><a href="#performing-side-effects-with-signals">Performing side effects with signals</a></strong></p>
<ol>
<li><a href="#subscription">Subscription</a></li>
<li><a href="#injecting-effects">Injecting effects</a></li>
</ol>
<p><strong><a href="#transforming-streams">Transforming streams</a></strong></p>
<ol>
<li><a href="#mapping">Mapping</a></li>
<li><a href="#filtering">Filtering</a></li>
</ol>
<p><strong><a href="#combining-streams">Combining streams</a></strong></p>
<ol>
<li><a href="#concatenating">Concatenating</a></li>
<li><a href="#flattening">Flattening</a></li>
<li><a href="#mapping-and-flattening">Mapping and flattening</a></li>
</ol>
<p><strong><a href="#combining-signals">Combining signals</a></strong></p>
<ol>
<li><a href="#sequencing">Sequencing</a></li>
<li><a href="#merging">Merging</a></li>
<li><a href="#combining-latest-values">Combining latest values</a></li>
<li><a href="#switching">Switching</a></li>
</ol>
<h2 id="Performing-side-effects-with-signals"><a href="#Performing-side-effects-with-signals" class="headerlink" title="Performing side effects with signals"></a>Performing side effects with signals</h2><p>Most signals start out “cold,” which means that they will not do any work until<br><a href="#subscription">subscription</a>.</p>
<p>Upon subscription, a signal or its <a href="FrameworkOverview.md#subscription">subscribers</a> can perform <em>side<br>effects</em>, like logging to the console, making a network request, updating the<br>user interface, etc.</p>
<p>Side effects can also be <a href="#injecting-effects">injected</a> into a signal, where<br>they won’t be performed immediately, but will instead take effect with each<br>subscription later.</p>
<h3 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h3><p>The <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">-subscribe…</a> methods give you access to the current and future values in a signal:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *letters = [<span class="string">@"A B C D E F G H I"</span> componentsSeparatedByString:<span class="string">@" "</span>].rac_sequence.signal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Outputs: A B C D E F G H I</span></span><br><span class="line">[letters subscribeNext:^(<span class="built_in">NSString</span> *x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>For a cold signal, side effects will be performed once <em>per subscription</em>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">unsigned</span> subscriptions = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">RACSignal *loggingSignal = [RACSignal createSignal:^ RACDisposable * (<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    subscriptions++;</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Outputs:</span></span><br><span class="line"><span class="comment">// subscription 1</span></span><br><span class="line">[loggingSignal subscribeCompleted:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subscription %u"</span>, subscriptions);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Outputs:</span></span><br><span class="line"><span class="comment">// subscription 2</span></span><br><span class="line">[loggingSignal subscribeCompleted:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subscription %u"</span>, subscriptions);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>This behavior can be changed using a <a href="FrameworkOverview.md#connections">connection</a>.</p>
<h3 id="Injecting-effects"><a href="#Injecting-effects" class="headerlink" title="Injecting effects"></a>Injecting effects</h3><p>The <a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">-do…</a> methods add side effects to a signal without actually<br>subscribing to it:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">unsigned</span> subscriptions = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">RACSignal *loggingSignal = [RACSignal createSignal:^ RACDisposable * (<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    subscriptions++;</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Does not output anything yet</span></span><br><span class="line">loggingSignal = [loggingSignal doCompleted:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"about to complete subscription %u"</span>, subscriptions);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Outputs:</span></span><br><span class="line"><span class="comment">// about to complete subscription 1</span></span><br><span class="line"><span class="comment">// subscription 1</span></span><br><span class="line">[loggingSignal subscribeCompleted:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subscription %u"</span>, subscriptions);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="Transforming-streams"><a href="#Transforming-streams" class="headerlink" title="Transforming streams"></a>Transforming streams</h2><p>These operators transform a single stream into a new stream.</p>
<h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><p>The <a href="../../ReactiveCocoa/Objective-C/RACStream.h">-map:</a> method is used to transform the values in a stream, and<br>create a new stream with the results:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *letters = [<span class="string">@"A B C D E F G H I"</span> componentsSeparatedByString:<span class="string">@" "</span>].rac_sequence;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains: AA BB CC DD EE FF GG HH II</span></span><br><span class="line">RACSequence *mapped = [letters map:^(<span class="built_in">NSString</span> *value) &#123;</span><br><span class="line">    <span class="keyword">return</span> [value stringByAppendingString:value];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h3><p>The <a href="../../ReactiveCocoa/Objective-C/RACStream.h">-filter:</a> method uses a block to test each value, including it<br>into the resulting stream only if the test passes:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *numbers = [<span class="string">@"1 2 3 4 5 6 7 8 9"</span> componentsSeparatedByString:<span class="string">@" "</span>].rac_sequence;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains: 2 4 6 8</span></span><br><span class="line">RACSequence *filtered = [numbers filter:^ <span class="built_in">BOOL</span> (<span class="built_in">NSString</span> *value) &#123;</span><br><span class="line">    <span class="keyword">return</span> (value.intValue % <span class="number">2</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="Combining-streams"><a href="#Combining-streams" class="headerlink" title="Combining streams"></a>Combining streams</h2><p>These operators combine multiple streams into a single new stream.</p>
<h3 id="Concatenating"><a href="#Concatenating" class="headerlink" title="Concatenating"></a>Concatenating</h3><p>The <a href="../../ReactiveCocoa/Objective-C/RACStream.h">-concat:</a> method appends one stream’s values to another:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *letters = [<span class="string">@"A B C D E F G H I"</span> componentsSeparatedByString:<span class="string">@" "</span>].rac_sequence;</span><br><span class="line">RACSequence *numbers = [<span class="string">@"1 2 3 4 5 6 7 8 9"</span> componentsSeparatedByString:<span class="string">@" "</span>].rac_sequence;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains: A B C D E F G H I 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">RACSequence *concatenated = [letters concat:numbers];</span><br></pre></td></tr></table></figure>
<h3 id="Flattening"><a href="#Flattening" class="headerlink" title="Flattening"></a>Flattening</h3><p>The <a href="../../ReactiveCocoa/Objective-C/RACStream.h">-flatten</a> operator is applied to a stream-of-streams, and<br>combines their values into a single new stream.</p>
<p>Sequences are <a href="#concatenating">concatenated</a>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *letters = [<span class="string">@"A B C D E F G H I"</span> componentsSeparatedByString:<span class="string">@" "</span>].rac_sequence;</span><br><span class="line">RACSequence *numbers = [<span class="string">@"1 2 3 4 5 6 7 8 9"</span> componentsSeparatedByString:<span class="string">@" "</span>].rac_sequence;</span><br><span class="line">RACSequence *sequenceOfSequences = @[ letters, numbers ].rac_sequence;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains: A B C D E F G H I 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">RACSequence *flattened = [sequenceOfSequences flatten];</span><br></pre></td></tr></table></figure>
<p>Signals are <a href="#merging">merged</a>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *letters = [RACSubject subject];</span><br><span class="line">RACSubject *numbers = [RACSubject subject];</span><br><span class="line">RACSignal *signalOfSignals = [RACSignal createSignal:^ RACDisposable * (<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:letters];</span><br><span class="line">    [subscriber sendNext:numbers];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *flattened = [signalOfSignals flatten];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Outputs: A 1 B C 2</span></span><br><span class="line">[flattened subscribeNext:^(<span class="built_in">NSString</span> *x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[letters sendNext:<span class="string">@"A"</span>];</span><br><span class="line">[numbers sendNext:<span class="string">@"1"</span>];</span><br><span class="line">[letters sendNext:<span class="string">@"B"</span>];</span><br><span class="line">[letters sendNext:<span class="string">@"C"</span>];</span><br><span class="line">[numbers sendNext:<span class="string">@"2"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="Mapping-and-flattening"><a href="#Mapping-and-flattening" class="headerlink" title="Mapping and flattening"></a>Mapping and flattening</h3><p><a href="#flattening">Flattening</a> isn’t that interesting on its own, but understanding<br>how it works is important for <a href="../../ReactiveCocoa/Objective-C/RACStream.h">-flattenMap:</a>.</p>
<p><code>-flattenMap:</code> is used to transform each of a stream’s values into <em>a new<br>stream</em>. Then, all of the streams returned will be flattened down into a single<br>stream. In other words, it’s <a href="#mapping">-map:</a> followed by <a href="#flattening">-flatten</a>.</p>
<p>This can be used to extend or edit sequences:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *numbers = [<span class="string">@"1 2 3 4 5 6 7 8 9"</span> componentsSeparatedByString:<span class="string">@" "</span>].rac_sequence;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains: 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</span></span><br><span class="line">RACSequence *extended = [numbers flattenMap:^(<span class="built_in">NSString</span> *num) &#123;</span><br><span class="line">    <span class="keyword">return</span> @[ num, num ].rac_sequence;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains: 1_ 3_ 5_ 7_ 9_</span></span><br><span class="line">RACSequence *edited = [numbers flattenMap:^(<span class="built_in">NSString</span> *num) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num.intValue % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [RACSequence empty];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *newNum = [num stringByAppendingString:<span class="string">@"_"</span>];</span><br><span class="line">        <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:newNum]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>Or create multiple signals of work which are automatically recombined:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *letters = [<span class="string">@"A B C D E F G H I"</span> componentsSeparatedByString:<span class="string">@" "</span>].rac_sequence.signal;</span><br><span class="line"></span><br><span class="line">[[letters</span><br><span class="line">    flattenMap:^(<span class="built_in">NSString</span> *letter) &#123;</span><br><span class="line">        <span class="keyword">return</span> [database saveEntriesForLetter:letter];</span><br><span class="line">    &#125;]</span><br><span class="line">    subscribeCompleted:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"All database entries saved successfully."</span>);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h2 id="Combining-signals"><a href="#Combining-signals" class="headerlink" title="Combining signals"></a>Combining signals</h2><p>These operators combine multiple signals into a single new <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a>.</p>
<h3 id="Sequencing"><a href="#Sequencing" class="headerlink" title="Sequencing"></a>Sequencing</h3><p><a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">-then:</a> starts the original signal,<br>waits for it to complete, and then only forwards the values from a new signal:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *letters = [<span class="string">@"A B C D E F G H I"</span> componentsSeparatedByString:<span class="string">@" "</span>].rac_sequence.signal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The new signal only contains: 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// But when subscribed to, it also outputs: A B C D E F G H I</span></span><br><span class="line">RACSignal *sequenced = [[letters</span><br><span class="line">    doNext:^(<span class="built_in">NSString</span> *letter) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, letter);</span><br><span class="line">    &#125;]</span><br><span class="line">    then:^&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">@"1 2 3 4 5 6 7 8 9"</span> componentsSeparatedByString:<span class="string">@" "</span>].rac_sequence.signal;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>This is most useful for executing all the side effects of one signal, then<br>starting another, and only returning the second signal’s values.</p>
<h3 id="Merging"><a href="#Merging" class="headerlink" title="Merging"></a>Merging</h3><p>The <a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">+merge:</a> method will forward the values from many<br>signals into a single stream, as soon as those values arrive:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *letters = [RACSubject subject];</span><br><span class="line">RACSubject *numbers = [RACSubject subject];</span><br><span class="line">RACSignal *merged = [RACSignal merge:@[ letters, numbers ]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Outputs: A 1 B C 2</span></span><br><span class="line">[merged subscribeNext:^(<span class="built_in">NSString</span> *x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[letters sendNext:<span class="string">@"A"</span>];</span><br><span class="line">[numbers sendNext:<span class="string">@"1"</span>];</span><br><span class="line">[letters sendNext:<span class="string">@"B"</span>];</span><br><span class="line">[letters sendNext:<span class="string">@"C"</span>];</span><br><span class="line">[numbers sendNext:<span class="string">@"2"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="Combining-latest-values"><a href="#Combining-latest-values" class="headerlink" title="Combining latest values"></a>Combining latest values</h3><p>The <a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">+combineLatest:</a> and <code>+combineLatest:reduce:</code> methods<br>will watch multiple signals for changes, and then send the latest values from<br><em>all</em> of them when a change occurs:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *letters = [RACSubject subject];</span><br><span class="line">RACSubject *numbers = [RACSubject subject];</span><br><span class="line">RACSignal *combined = [RACSignal</span><br><span class="line">    combineLatest:@[ letters, numbers ]</span><br><span class="line">    reduce:^(<span class="built_in">NSString</span> *letter, <span class="built_in">NSString</span> *number) &#123;</span><br><span class="line">        <span class="keyword">return</span> [letter stringByAppendingString:number];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Outputs: B1 B2 C2 C3</span></span><br><span class="line">[combined subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[letters sendNext:<span class="string">@"A"</span>];</span><br><span class="line">[letters sendNext:<span class="string">@"B"</span>];</span><br><span class="line">[numbers sendNext:<span class="string">@"1"</span>];</span><br><span class="line">[numbers sendNext:<span class="string">@"2"</span>];</span><br><span class="line">[letters sendNext:<span class="string">@"C"</span>];</span><br><span class="line">[numbers sendNext:<span class="string">@"3"</span>];</span><br></pre></td></tr></table></figure>
<p>Note that the combined signal will only send its first value when all of the<br>inputs have sent at least one. In the example above, <code>@&quot;A&quot;</code> was never<br>forwarded because <code>numbers</code> had not sent a value yet.</p>
<h3 id="Switching"><a href="#Switching" class="headerlink" title="Switching"></a>Switching</h3><p>The <a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">-switchToLatest</a> operator is applied to<br>a signal-of-signals, and always forwards the values from the latest signal:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *letters = [RACSubject subject];</span><br><span class="line">RACSubject *numbers = [RACSubject subject];</span><br><span class="line">RACSubject *signalOfSignals = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">RACSignal *switched = [signalOfSignals switchToLatest];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Outputs: A B 1 D</span></span><br><span class="line">[switched subscribeNext:^(<span class="built_in">NSString</span> *x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:letters];</span><br><span class="line">[letters sendNext:<span class="string">@"A"</span>];</span><br><span class="line">[letters sendNext:<span class="string">@"B"</span>];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:numbers];</span><br><span class="line">[letters sendNext:<span class="string">@"C"</span>];</span><br><span class="line">[numbers sendNext:<span class="string">@"1"</span>];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:letters];</span><br><span class="line">[numbers sendNext:<span class="string">@"2"</span>];</span><br><span class="line">[letters sendNext:<span class="string">@"D"</span>];</span><br></pre></td></tr></table></figure>
<h1 id="Design-Guidelines"><a href="#Design-Guidelines" class="headerlink" title="Design Guidelines"></a>Design Guidelines</h1><p>This document contains guidelines for projects that want to make use of<br>ReactiveCocoa. The content here is heavily inspired by the <a href="http://blogs.msdn.com/b/rxteam/archive/2010/10/28/rx-design-guidelines.aspx" target="_blank" rel="noopener">Rx Design<br>Guidelines</a>.</p>
<p>This document assumes basic familiarity<br>with the features of ReactiveCocoa. The <a href="FrameworkOverview.md">Framework Overview</a> is a better<br>resource for getting up to speed on the functionality provided by RAC.</p>
<p><strong><a href="#the-racsequence-contract">The RACSequence contract</a></strong></p>
<ol>
<li><a href="#evaluation-occurs-lazily-by-default">Evaluation occurs lazily by default</a></li>
<li><a href="#evaluation-blocks-the-caller">Evaluation blocks the caller</a></li>
<li><a href="#side-effects-occur-only-once">Side effects occur only once</a></li>
</ol>
<p><strong><a href="#the-racsignal-contract">The RACSignal contract</a></strong></p>
<ol>
<li><a href="#signal-events-are-serialized">Signal events are serialized</a></li>
<li><a href="#subscription-will-always-occur-on-a-scheduler">Subscription will always occur on a scheduler</a></li>
<li><a href="#errors-are-propagated-immediately">Errors are propagated immediately</a></li>
<li><a href="#side-effects-occur-for-each-subscription">Side effects occur for each subscription</a></li>
<li><a href="#subscriptions-are-automatically-disposed-upon-completion-or-error">Subscriptions are automatically disposed upon completion or error</a></li>
<li><a href="#disposal-cancels-in-progress-work-and-cleans-up-resources">Disposal cancels in-progress work and cleans up resources</a></li>
</ol>
<p><strong><a href="#best-practices">Best practices</a></strong></p>
<ol>
<li><a href="#use-descriptive-declarations-for-methods-and-properties-that-return-a-signal">Use descriptive declarations for methods and properties that return a signal</a></li>
<li><a href="#indent-stream-operations-consistently">Indent stream operations consistently</a></li>
<li><a href="#use-the-same-type-for-all-the-values-of-a-stream">Use the same type for all the values of a stream</a></li>
<li><a href="#avoid-retaining-streams-for-too-long">Avoid retaining streams for too long</a></li>
<li><a href="#process-only-as-much-of-a-stream-as-needed">Process only as much of a stream as needed</a></li>
<li><a href="#deliver-signal-events-onto-a-known-scheduler">Deliver signal events onto a known scheduler</a></li>
<li><a href="#switch-schedulers-in-as-few-places-as-possible">Switch schedulers in as few places as possible</a></li>
<li><a href="#make-the-side-effects-of-a-signal-explicit">Make the side effects of a signal explicit</a></li>
<li><a href="#share-the-side-effects-of-a-signal-by-multicasting">Share the side effects of a signal by multicasting</a></li>
<li><a href="#debug-streams-by-giving-them-names">Debug streams by giving them names</a></li>
<li><a href="#avoid-explicit-subscriptions-and-disposal">Avoid explicit subscriptions and disposal</a></li>
<li><a href="#avoid-using-subjects-when-possible">Avoid using subjects when possible</a></li>
</ol>
<p><strong><a href="#implementing-new-operators">Implementing new operators</a></strong></p>
<ol>
<li><a href="#prefer-building-on-racstream-methods">Prefer building on RACStream methods</a></li>
<li><a href="#compose-existing-operators-when-possible">Compose existing operators when possible</a></li>
<li><a href="#avoid-introducing-concurrency">Avoid introducing concurrency</a></li>
<li><a href="#cancel-work-and-clean-up-all-resources-in-a-disposable">Cancel work and clean up all resources in a disposable</a></li>
<li><a href="#do-not-block-in-an-operator">Do not block in an operator</a></li>
<li><a href="#avoid-stack-overflow-from-deep-recursion">Avoid stack overflow from deep recursion</a></li>
</ol>
<h2 id="The-RACSequence-contract"><a href="#The-RACSequence-contract" class="headerlink" title="The RACSequence contract"></a>The RACSequence contract</h2><p><a href="../../ReactiveCocoa/Objective-C/RACSequence.h">RACSequence</a> is a <em>pull-driven</em> stream. Sequences behave similarly to<br>built-in collections, but with a few unique twists.</p>
<h3 id="Evaluation-occurs-lazily-by-default"><a href="#Evaluation-occurs-lazily-by-default" class="headerlink" title="Evaluation occurs lazily by default"></a>Evaluation occurs lazily by default</h3><p>Sequences are evaluated lazily by default. For example, in this sequence:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *strings = @[ <span class="string">@"A"</span>, <span class="string">@"B"</span>, <span class="string">@"C"</span> ];</span><br><span class="line">RACSequence *sequence = [strings.rac_sequence map:^(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">    <span class="keyword">return</span> [str stringByAppendingString:<span class="string">@"_"</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>… no string appending is actually performed until the values of the sequence are<br>needed. Accessing <code>sequence.head</code> will perform the concatenation of <code>A_</code>,<br>accessing <code>sequence.tail.head</code> will perform the concatenation of <code>B_</code>, and so<br>on.</p>
<p>This generally avoids performing unnecessary work (since values that are never<br>used are never calculated), but means that sequence processing <a href="#process-only-as-much-of-a-stream-as-needed">should be<br>limited only to what’s actually<br>needed</a>.</p>
<p>Once evaluated, the values in a sequence are memoized and do not need to be<br>recalculated. Accessing <code>sequence.head</code> multiple times will only do the work of<br>one string concatenation.</p>
<p>If lazy evaluation is undesirable – for instance, because limiting memory usage<br>is more important than avoiding unnecessary work – the<br><a href="../../ReactiveCocoa/Objective-C/RACSequence.h">eagerSequence</a> property can be used to force a sequence (and any<br>sequences derived from it afterward) to evaluate eagerly.</p>
<h3 id="Evaluation-blocks-the-caller"><a href="#Evaluation-blocks-the-caller" class="headerlink" title="Evaluation blocks the caller"></a>Evaluation blocks the caller</h3><p>Regardless of whether a sequence is lazy or eager, evaluation of any part of<br>a sequence will block the calling thread until completed. This is necessary<br>because values must be synchronously retrieved from a sequence.</p>
<p>If evaluating a sequence is expensive enough that it might block the thread for<br>a significant amount of time, consider creating a signal with<br><a href="../../ReactiveCocoa/Objective-C/RACSequence.h">-signalWithScheduler:</a> and using that instead.</p>
<h3 id="Side-effects-occur-only-once"><a href="#Side-effects-occur-only-once" class="headerlink" title="Side effects occur only once"></a>Side effects occur only once</h3><p>When the block passed to a sequence operator involves side effects, it is<br>important to realize that those side effects will only occur once per value<br>– namely, when the value is evaluated:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *strings = @[ <span class="string">@"A"</span>, <span class="string">@"B"</span>, <span class="string">@"C"</span> ];</span><br><span class="line">RACSequence *sequence = [strings.rac_sequence map:^(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">    <span class="keyword">return</span> [str stringByAppendingString:<span class="string">@"_"</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs "A" during this call.</span></span><br><span class="line"><span class="built_in">NSString</span> *concatA = sequence.head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs "B" during this call.</span></span><br><span class="line"><span class="built_in">NSString</span> *concatB = sequence.tail.head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Does not log anything.</span></span><br><span class="line"><span class="built_in">NSString</span> *concatB2 = sequence.tail.head;</span><br><span class="line"></span><br><span class="line">RACSequence *derivedSequence = [sequence map:^(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">@"_"</span> stringByAppendingString:str];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Still does not log anything, because "B_" was already evaluated, and the log</span></span><br><span class="line"><span class="comment">// statement associated with it will never be re-executed.</span></span><br><span class="line"><span class="built_in">NSString</span> *concatB3 = derivedSequence.tail.head;</span><br></pre></td></tr></table></figure>
<h2 id="The-RACSignal-contract"><a href="#The-RACSignal-contract" class="headerlink" title="The RACSignal contract"></a>The RACSignal contract</h2><p><a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a> is a <em>push-driven</em> stream with a focus on asynchronous event<br>delivery through <em>subscriptions</em>. For more information about signals and<br>subscriptions, see the <a href="FrameworkOverview.md">Framework Overview</a>.</p>
<h3 id="Signal-events-are-serialized"><a href="#Signal-events-are-serialized" class="headerlink" title="Signal events are serialized"></a>Signal events are serialized</h3><p>A signal may choose to deliver its events on any thread. Consecutive events are<br>even allowed to arrive on different threads or schedulers, unless explicitly<br><a href="#deliver-signal-events-onto-a-known-scheduler">delivered onto a particular<br>scheduler</a>.</p>
<p>However, RAC guarantees that no two signal events will ever arrive concurrently.<br>While an event is being processed, no other events will be delivered. The<br>senders of any other events will be forced to wait until the current event has<br>been handled.</p>
<p>Most notably, this means that the blocks passed to<br><a href="../../ReactiveCocoa/Objective-C/RACSignal.h">-subscribeNext:error:completed:</a> do not need to be synchronized with<br>respect to each other, because they will never be invoked simultaneously.</p>
<h3 id="Subscription-will-always-occur-on-a-scheduler"><a href="#Subscription-will-always-occur-on-a-scheduler" class="headerlink" title="Subscription will always occur on a scheduler"></a>Subscription will always occur on a scheduler</h3><p>To ensure consistent behavior for the <code>+createSignal:</code> and <code>-subscribe:</code><br>methods, each <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a> subscription is guaranteed to take place on<br>a valid <a href="../../ReactiveCocoa/Objective-C/RACScheduler.h">RACScheduler</a>.</p>
<p>If the subscriber’s thread already has a <a href="../../ReactiveCocoa/Objective-C/RACScheduler.h">+currentScheduler</a>,<br>scheduling takes place immediately; otherwise, scheduling occurs as soon as<br>possible on a background scheduler. Note that the main thread is always<br>associated with the <a href="../../ReactiveCocoa/Objective-C/RACScheduler.h">+mainThreadScheduler</a>, so subscription will<br>always be immediate there.</p>
<p>See the documentation for <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">-subscribe:</a> for more information.</p>
<h3 id="Errors-are-propagated-immediately"><a href="#Errors-are-propagated-immediately" class="headerlink" title="Errors are propagated immediately"></a>Errors are propagated immediately</h3><p>In RAC, <code>error</code> events have exception semantics. When an error is sent on<br>a signal, it will be immediately forwarded to all dependent signals, causing the<br>entire chain to terminate.</p>
<p><a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">Operators</a> whose primary purpose is to change<br>error-handling behavior – like <code>-catch:</code>, <code>-catchTo:</code>, or <code>-materialize</code> – are<br>obviously not subject to this rule.</p>
<h3 id="Side-effects-occur-for-each-subscription"><a href="#Side-effects-occur-for-each-subscription" class="headerlink" title="Side effects occur for each subscription"></a>Side effects occur for each subscription</h3><p>Each new subscription to a <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a> will trigger its side effects. This<br>means that any side effects will happen as many times as subscriptions to the<br>signal itself.</p>
<p>Consider this example:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> aNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Signal that will have the side effect of incrementing `aNumber` block </span></span><br><span class="line"><span class="comment">// variable for each subscription before sending it.</span></span><br><span class="line">RACSignal *aSignal = [RACSignal createSignal:^ RACDisposable * (<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">	aNumber++;</span><br><span class="line">	[subscriber sendNext:@(aNumber)];</span><br><span class="line">	[subscriber sendCompleted];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will print "subscriber one: 1"</span></span><br><span class="line">[aSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"subscriber one: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will print "subscriber two: 2"</span></span><br><span class="line">[aSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"subscriber two: %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>Side effects are repeated for each subscription. The same applies to<br><a href="../../ReactiveCocoa/Objective-C/RACStream.h">stream</a> and <a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">signal</a> operators:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> missilesToLaunch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Signal that will have the side effect of changing `missilesToLaunch` on</span></span><br><span class="line"><span class="comment">// subscription.</span></span><br><span class="line">RACSignal *processedSignal = [[RACSignal</span><br><span class="line">    <span class="keyword">return</span>:<span class="string">@"missiles"</span>]</span><br><span class="line">	map:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">		missilesToLaunch++;</span><br><span class="line">		<span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"will launch %d %@"</span>, missilesToLaunch, x];</span><br><span class="line">	&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will print "First will launch 1 missiles"</span></span><br><span class="line">[processedSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"First %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will print "Second will launch 2 missiles"</span></span><br><span class="line">[processedSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"Second %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>To suppress this behavior and have multiple subscriptions to a signal execute<br>its side effects only once, a signal can be<br><a href="#share-the-side-effects-of-a-signal-by-multicasting">multicasted</a>.</p>
<p>Side effects can be insidious and produce problems that are difficult to<br>diagnose. For this reason it is suggested to<br><a href="#make-the-side-effects-of-a-signal-explicit">make side effects explicit</a> when<br>possible.</p>
<h3 id="Subscriptions-are-automatically-disposed-upon-completion-or-error"><a href="#Subscriptions-are-automatically-disposed-upon-completion-or-error" class="headerlink" title="Subscriptions are automatically disposed upon completion or error"></a>Subscriptions are automatically disposed upon completion or error</h3><p>When a <a href="../../ReactiveCocoa/Objective-C/RACSubscriber.h">subscriber</a> is sent a <code>completed</code> or <code>error</code> event, the<br>associated subscription will automatically be disposed. This behavior usually<br>eliminates the need to manually dispose of subscriptions.</p>
<p>See the <a href="MemoryManagement.md">Memory Management</a> document for more information about signal<br>lifetime.</p>
<h3 id="Disposal-cancels-in-progress-work-and-cleans-up-resources"><a href="#Disposal-cancels-in-progress-work-and-cleans-up-resources" class="headerlink" title="Disposal cancels in-progress work and cleans up resources"></a>Disposal cancels in-progress work and cleans up resources</h3><p>When a subscription is disposed, manually or automatically, any in-progress or<br>outstanding work associated with that subscription is gracefully cancelled as<br>soon as possible, and any resources associated with the subscription are cleaned<br>up.</p>
<p>Disposing of the subscription to a signal representing a file upload, for<br>example, would cancel any in-flight network request, and free the file data from<br>memory.</p>
<h2 id="Best-practices"><a href="#Best-practices" class="headerlink" title="Best practices"></a>Best practices</h2><p>The following recommendations are intended to help keep RAC-based code<br>predictable, understandable, and performant.</p>
<p>They are, however, only guidelines. Use best judgement when determining whether<br>to apply the recommendations here to a given piece of code.</p>
<h3 id="Use-descriptive-declarations-for-methods-and-properties-that-return-a-signal"><a href="#Use-descriptive-declarations-for-methods-and-properties-that-return-a-signal" class="headerlink" title="Use descriptive declarations for methods and properties that return a signal"></a>Use descriptive declarations for methods and properties that return a signal</h3><p>When a method or property has a return type of <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a>, it can be<br>difficult to understand the signal’s semantics at a glance.</p>
<p>There are three key questions that can inform a declaration:</p>
<ol>
<li>Is the signal <em>hot</em> (already activated by the time it’s returned to the<br>caller) or <em>cold</em> (activated when subscribed to)?</li>
<li>Will the signal include zero, one, or more values?</li>
<li>Does the signal have side effects?</li>
</ol>
<p><strong>Hot signals without side effects</strong> should typically be properties instead of<br>methods. The use of a property indicates that no initialization is needed before<br>subscribing to the signal’s events, and that additional subscribers will not<br>change the semantics. Signal properties should usually be named after events<br>(e.g., <code>textChanged</code>).</p>
<p><strong>Cold signals without side effects</strong> should be returned from methods that have<br>noun-like names (e.g., <code>-currentText</code>). A method declaration indicates that the<br>signal might not be kept around, hinting that work is performed at the time of<br>subscription. If the signal sends multiple values, the noun should be pluralized<br>(e.g., <code>-currentModels</code>).</p>
<p><strong>Signals with side effects</strong> should be returned from methods that have<br>verb-like names (e.g., <code>-logIn</code>). The verb indicates that the method is not<br>idempotent and that callers must be careful to call it only when the side<br>effects are desired. If the signal will send one or more values, include a noun<br>that describes them (e.g., <code>-loadConfiguration</code>, <code>-fetchLatestEvents</code>).</p>
<h3 id="Indent-stream-operations-consistently"><a href="#Indent-stream-operations-consistently" class="headerlink" title="Indent stream operations consistently"></a>Indent stream operations consistently</h3><p>It’s easy for stream-heavy code to become very dense and confusing if not<br>properly formatted. Use consistent indentation to highlight where chains of<br>streams begin and end.</p>
<p>When invoking a single method upon a stream, no additional indentation is<br>necessary (block arguments aside):</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACStream *result = [stream startWith:@<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">RACStream *result2 = [stream map:^(<span class="built_in">NSNumber</span> *value) &#123;</span><br><span class="line">    <span class="keyword">return</span> @(value.integerValue + <span class="number">1</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>When transforming the same stream multiple times, ensure that all of the<br>steps are aligned. Complex operators like <a href="../../ReactiveCocoa/Objective-C/RACStream.h">+zip:reduce:</a> or<br><a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">+combineLatest:reduce:</a> may be split over multiple lines<br>for readability:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RACStream *result = [[[RACStream</span><br><span class="line">    zip:@[ firstStream, secondStream ]</span><br><span class="line">    reduce:^(<span class="built_in">NSNumber</span> *first, <span class="built_in">NSNumber</span> *second) &#123;</span><br><span class="line">        <span class="keyword">return</span> @(first.integerValue + second.integerValue);</span><br><span class="line">    &#125;]</span><br><span class="line">    filter:^ <span class="built_in">BOOL</span> (<span class="built_in">NSNumber</span> *value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.integerValue &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;]</span><br><span class="line">    map:^(<span class="built_in">NSNumber</span> *value) &#123;</span><br><span class="line">        <span class="keyword">return</span> @(value.integerValue + <span class="number">1</span>);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>Of course, streams nested within block arguments should start at the natural<br>indentation of the block:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[[signal</span><br><span class="line">    then:^&#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [[<span class="keyword">self</span></span><br><span class="line">            doSomethingElse]</span><br><span class="line">            catch:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                @strongify(<span class="keyword">self</span>);</span><br><span class="line">                [<span class="keyword">self</span> presentError:error];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> [RACSignal empty];</span><br><span class="line">            &#125;];</span><br><span class="line">    &#125;]</span><br><span class="line">    subscribeCompleted:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"All done."</span>);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="Use-the-same-type-for-all-the-values-of-a-stream"><a href="#Use-the-same-type-for-all-the-values-of-a-stream" class="headerlink" title="Use the same type for all the values of a stream"></a>Use the same type for all the values of a stream</h3><p><a href="../../ReactiveCocoa/Objective-C/RACStream.h">RACStream</a> (and, by extension, <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a> and <a href="../../ReactiveCocoa/Objective-C/RACSequence.h">RACSequence</a>) allows<br>streams to be composed of heterogenous objects, just like Cocoa collections do.<br>However, using different object types within the same stream complicates the use<br>of operators and<br>puts an additional burden on any consumers of that stream, who must be careful to<br>only invoke supported methods.</p>
<p>Whenever possible, streams should only contain objects of the same type.</p>
<h3 id="Avoid-retaining-streams-for-too-long"><a href="#Avoid-retaining-streams-for-too-long" class="headerlink" title="Avoid retaining streams for too long"></a>Avoid retaining streams for too long</h3><p>Retaining any <a href="../../ReactiveCocoa/Objective-C/RACStream.h">RACStream</a> longer than it’s needed will cause any dependencies<br>to be retained as well, potentially keeping memory usage much higher than it<br>would be otherwise.</p>
<p>A <a href="../../ReactiveCocoa/Objective-C/RACSequence.h">RACSequence</a> should be retained only for as long as the <code>head</code> of the<br>sequence is needed. If the head will no longer be used, retain the <code>tail</code> of the<br>node instead of the node itself.</p>
<p>See the <a href="MemoryManagement.md">Memory Management</a> guide for more information on object lifetime.</p>
<h3 id="Process-only-as-much-of-a-stream-as-needed"><a href="#Process-only-as-much-of-a-stream-as-needed" class="headerlink" title="Process only as much of a stream as needed"></a>Process only as much of a stream as needed</h3><p>As well as <a href="#avoid-retaining-streams-for-too-long">consuming additional<br>memory</a>, unnecessarily<br>keeping a stream or <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a> subscription alive can result in increased CPU<br>usage, as unnecessary work is performed for results that will never be used.</p>
<p>If only a certain number of values are needed from a stream, the<br><a href="../../ReactiveCocoa/Objective-C/RACStream.h">-take:</a> operator can be used to retrieve only that many values, and<br>then automatically terminate the stream immediately thereafter.</p>
<p>Operators like <code>-take:</code> and <a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">-takeUntil:</a> automatically propagate cancellation<br>up the stack as well. If nothing else needs the rest of the values, any<br>dependencies will be terminated too, potentially saving a significant amount of<br>work.</p>
<h3 id="Deliver-signal-events-onto-a-known-scheduler"><a href="#Deliver-signal-events-onto-a-known-scheduler" class="headerlink" title="Deliver signal events onto a known scheduler"></a>Deliver signal events onto a known scheduler</h3><p>When a signal is returned from a method, or combined with such a signal, it can<br>be difficult to know which thread events will be delivered upon. Although<br>events are <a href="#signal-events-are-serialized">guaranteed to be serial</a>, sometimes<br>stronger guarantees are needed, like when performing UI updates (which must<br>occur on the main thread).</p>
<p>Whenever such a guarantee is important, the <a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">-deliverOn:</a><br>operator should be used to force a signal’s events to arrive on a specific<br><a href="../../ReactiveCocoa/Objective-C/RACScheduler.h">RACScheduler</a>.</p>
<h3 id="Switch-schedulers-in-as-few-places-as-possible"><a href="#Switch-schedulers-in-as-few-places-as-possible" class="headerlink" title="Switch schedulers in as few places as possible"></a>Switch schedulers in as few places as possible</h3><p>Notwithstanding the above, events should only be delivered to a specific<br><a href="../../ReactiveCocoa/Objective-C/RACScheduler.h">scheduler</a> when absolutely necessary. Switching schedulers can<br>introduce unnecessary delays and cause an increase in CPU load.</p>
<p>Generally, the use of <a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">-deliverOn:</a> should be restricted<br>to the end of a signal chain – e.g., before subscription, or before the values<br>are bound to a property.</p>
<h3 id="Make-the-side-effects-of-a-signal-explicit"><a href="#Make-the-side-effects-of-a-signal-explicit" class="headerlink" title="Make the side effects of a signal explicit"></a>Make the side effects of a signal explicit</h3><p>As much as possible, <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a> side effects should be avoided, because<br>subscribers may find the <a href="#side-effects-occur-for-each-subscription">behavior of side<br>effects</a> unexpected.</p>
<p>However, because Cocoa is predominantly imperative, it is sometimes useful to<br>perform side effects when signal events occur. Although most <a href="../../ReactiveCocoa/Objective-C/RACStream.h">RACStream</a> and<br><a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">RACSignal</a> operators accept arbitrary blocks (which can<br>contain side effects), the use of <code>-doNext:</code>, <code>-doError:</code>, and <code>-doCompleted:</code><br>will make side effects more explicit and self-documenting:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *nexts = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">__block <span class="built_in">NSError</span> *receivedError = <span class="literal">nil</span>;</span><br><span class="line">__block <span class="built_in">BOOL</span> success = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">RACSignal *bookkeepingSignal = [[[valueSignal</span><br><span class="line">    doNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        [nexts addObject:x];</span><br><span class="line">    &#125;]</span><br><span class="line">    doError:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        receivedError = error;</span><br><span class="line">    &#125;]</span><br><span class="line">    doCompleted:^&#123;</span><br><span class="line">        success = <span class="literal">YES</span>;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">RAC(<span class="keyword">self</span>, value) = bookkeepingSignal;</span><br></pre></td></tr></table></figure>
<h3 id="Share-the-side-effects-of-a-signal-by-multicasting"><a href="#Share-the-side-effects-of-a-signal-by-multicasting" class="headerlink" title="Share the side effects of a signal by multicasting"></a>Share the side effects of a signal by multicasting</h3><p><a href="#side-effects-occur-for-each-subscription">Side effects occur for each<br>subscription</a> by default, but there<br>are certain situations where side effects should only occur once – for example,<br>a network request typically should not be repeated when a new subscriber is<br>added.</p>
<p>The <code>-publish</code> and <code>-multicast:</code> operators of <a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">RACSignal</a><br>allow a single subscription to be shared to any number of subscribers by using<br>a <a href="../../ReactiveCocoa/Objective-C/RACMulticastConnection.h">RACMulticastConnection</a>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This signal starts a new request on each subscription.</span></span><br><span class="line">RACSignal *networkRequest = [RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    AFHTTPRequestOperation *operation = [client</span><br><span class="line">        HTTPRequestOperationWithRequest:request</span><br><span class="line">        success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> response) &#123;</span><br><span class="line">            [subscriber sendNext:response];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;</span><br><span class="line">        failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">            [subscriber sendError:error];</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">    [client enqueueHTTPRequestOperation:operation];</span><br><span class="line">    <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        [operation cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Starts a single request, no matter how many subscriptions `connection.signal`</span></span><br><span class="line"><span class="comment">// gets. This is equivalent to the -replay operator, or similar to</span></span><br><span class="line"><span class="comment">// +startEagerlyWithScheduler:block:.</span></span><br><span class="line">RACMulticastConnection *connection = [networkRequest multicast:[RACReplaySubject subject]];</span><br><span class="line">[connection connect];</span><br><span class="line"></span><br><span class="line">[connection.signal subscribeNext:^(<span class="keyword">id</span> response) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subscriber one: %@"</span>, response);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[connection.signal subscribeNext:^(<span class="keyword">id</span> response) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subscriber two: %@"</span>, response);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="Debug-streams-by-giving-them-names"><a href="#Debug-streams-by-giving-them-names" class="headerlink" title="Debug streams by giving them names"></a>Debug streams by giving them names</h3><p>Every <a href="../../ReactiveCocoa/Objective-C/RACStream.h">RACStream</a> has a <code>name</code> property to assist with debugging. A stream’s<br><code>-description</code> includes its name, and all operators provided by RAC will<br>automatically add to the name. This usually makes it possible to identify<br>a stream from its default name alone.</p>
<p>For example, this snippet:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [[[RACObserve(<span class="keyword">self</span>, username) </span><br><span class="line">    distinctUntilChanged] </span><br><span class="line">    take:<span class="number">3</span>] </span><br><span class="line">    filter:^(<span class="built_in">NSString</span> *newUsername) &#123;</span><br><span class="line">        <span class="keyword">return</span> [newUsername isEqualToString:<span class="string">@"joshaber"</span>];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, signal);</span><br></pre></td></tr></table></figure>
<p>… would log a name similar to <code>[[[RACObserve(self, username)] -distinctUntilChanged]
-take: 3] -filter:</code>.</p>
<p>Names can also be manually applied by using <a href="../../ReactiveCocoa/Objective-C/RACStream.h">-setNameWithFormat:</a>.</p>
<p><a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a> also offers <code>-logNext</code>, <code>-logError</code>,<br><code>-logCompleted</code>, and <code>-logAll</code> methods, which will automatically log signal<br>events as they occur, and include the name of the signal in the messages. This<br>can be used to conveniently inspect a signal in real-time.</p>
<h3 id="Avoid-explicit-subscriptions-and-disposal"><a href="#Avoid-explicit-subscriptions-and-disposal" class="headerlink" title="Avoid explicit subscriptions and disposal"></a>Avoid explicit subscriptions and disposal</h3><p>Although <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">-subscribeNext:error:completed:</a> and its variants are the<br>most basic way to process a signal, their use can complicate code by<br>being less declarative, encouraging the use of side effects, and potentially<br>duplicating built-in functionality.</p>
<p>Likewise, explicit use of the <a href="../../ReactiveCocoa/Objective-C/RACDisposable.h">RACDisposable</a> class can quickly lead to<br>a rat’s nest of resource management and cleanup code.</p>
<p>There are almost always higher-level patterns that can be used instead of manual<br>subscriptions and disposal:</p>
<ul>
<li>The <a href="../../ReactiveCocoa/Objective-C/RACSubscriptingAssignmentTrampoline.h">RAC()</a> or <a href="../../ReactiveCocoa/Objective-C/RACKVOChannel.h">RACChannelTo()</a> macros can be used to bind<br>a signal to a property, instead of performing manual updates when changes<br>occur.</li>
<li>The <a href="../../ReactiveCocoa/Objective-C/NSObject+RACLifting.h">-rac_liftSelector:withSignals:</a> method can be used<br>to automatically invoke a selector when one or more signals fire.</li>
<li>Operators like <a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">-takeUntil:</a> can be used to<br>automatically dispose of a subscription when an event occurs (like a “Cancel”<br>button being pressed in the UI).</li>
</ul>
<p>Generally, the use of built-in <a href="../../ReactiveCocoa/Objective-C/RACStream.h">stream</a> and<br><a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">signal</a> operators will lead to simpler and less<br>error-prone code than replicating the same behaviors in a subscription callback.</p>
<h3 id="Avoid-using-subjects-when-possible"><a href="#Avoid-using-subjects-when-possible" class="headerlink" title="Avoid using subjects when possible"></a>Avoid using subjects when possible</h3><p><a href="FrameworkOverview.md#subjects">Subjects</a> are a powerful tool for bridging imperative code<br>into the world of signals, but, as the “mutable variables” of RAC, they can<br>quickly lead to complexity when overused.</p>
<p>Since they can be manipulated from anywhere, at any time, subjects often break<br>the linear flow of stream processing and make logic much harder to follow. They<br>also don’t support meaningful<br><a href="#disposal-cancels-in-progress-work-and-cleans-up-resources">disposal</a>, which<br>can result in unnecessary work.</p>
<p>Subjects can usually be replaced with other patterns from ReactiveCocoa:</p>
<ul>
<li>Instead of feeding initial values into a subject, consider generating the<br>values in a <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">+createSignal:</a> block instead.</li>
<li>Instead of delivering intermediate results to a subject, try combining the<br>output of multiple signals with operators like<br><a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">+combineLatest:</a> or <a href="../../ReactiveCocoa/Objective-C/RACStream.h">+zip:</a>.</li>
<li>Instead of using subjects to share results with multiple subscribers,<br><a href="#share-the-side-effects-of-a-signal-by-multicasting">multicast</a> a base<br>signal instead.</li>
<li>Instead of implementing an action method which simply controls a subject, use<br>a <a href="../../ReactiveCocoa/Objective-C/RACCommand.h">command</a> or<br><a href="../../ReactiveCocoa/Objective-C/NSObject+RACSelectorSignal.h">-rac_signalForSelector:</a> instead.</li>
</ul>
<p>When subjects <em>are</em> necessary, they should almost always be the “base” input<br>for a signal chain, not used in the middle of one.</p>
<h2 id="Implementing-new-operators"><a href="#Implementing-new-operators" class="headerlink" title="Implementing new operators"></a>Implementing new operators</h2><p>RAC provides a long list of built-in operators for <a href="../../ReactiveCocoa/Objective-C/RACStream.h">streams</a> and<br><a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">signals</a> that should cover most use cases; however, RAC<br>is not a closed system. It’s entirely valid to implement additional operators<br>for specialized uses, or for consideration in ReactiveCocoa itself.</p>
<p>Implementing a new operator requires a careful attention to detail and a focus<br>on simplicity, to avoid introducing bugs into the calling code.</p>
<p>These guidelines cover some of the common pitfalls and help preserve the<br>expected API contracts.</p>
<h3 id="Prefer-building-on-RACStream-methods"><a href="#Prefer-building-on-RACStream-methods" class="headerlink" title="Prefer building on RACStream methods"></a>Prefer building on RACStream methods</h3><p><a href="../../ReactiveCocoa/Objective-C/RACStream.h">RACStream</a> offers a simpler interface than <a href="../../ReactiveCocoa/Objective-C/RACSequence.h">RACSequence</a> and <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a>,<br>and all stream operators are automatically applicable to sequences and signals<br>as well.</p>
<p>For these reasons, new operators should be implemented using only <a href="../../ReactiveCocoa/Objective-C/RACStream.h">RACStream</a><br>methods whenever possible. The minimal required methods of the class, including<br><code>-bind:</code>, <code>-zipWith:</code>, and <code>-concat:</code>, are quite powerful, and many tasks can<br>be accomplished without needing anything else.</p>
<p>If a new <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a> operator needs to handle <code>error</code> and <code>completed</code> events,<br>consider using the <a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">-materialize</a> method to bring the<br>events into the stream. All of the events of a materialized signal can be<br>manipulated by stream operators, which helps minimize the use of non-stream<br>operators.</p>
<h3 id="Compose-existing-operators-when-possible"><a href="#Compose-existing-operators-when-possible" class="headerlink" title="Compose existing operators when possible"></a>Compose existing operators when possible</h3><p>Considerable thought has been put into the operators provided by RAC, and they<br>have been validated through automated tests and through their real world use in<br>other projects. An operator that has been written from scratch may not be as<br>robust, or might not handle a special case that the built-in operators are aware<br>of.</p>
<p>To minimize duplication and possible bugs, use the provided operators as much as<br>possible in a custom operator implementation. Generally, there should be very<br>little code written from scratch.</p>
<h3 id="Avoid-introducing-concurrency"><a href="#Avoid-introducing-concurrency" class="headerlink" title="Avoid introducing concurrency"></a>Avoid introducing concurrency</h3><p>Concurrency is an extremely common source of bugs in programming. To minimize<br>the potential for deadlocks and race conditions, operators should not<br>concurrently perform their work.</p>
<p>Callers always have the ability to subscribe or deliver events on a specific<br><a href="../../ReactiveCocoa/Objective-C/RACScheduler.h">RACScheduler</a>, and RAC offers powerful ways to <a href="../README.md#parallelizing-independent-work">parallelize<br>work</a> without making operators unnecessarily<br>complex.</p>
<h3 id="Cancel-work-and-clean-up-all-resources-in-a-disposable"><a href="#Cancel-work-and-clean-up-all-resources-in-a-disposable" class="headerlink" title="Cancel work and clean up all resources in a disposable"></a>Cancel work and clean up all resources in a disposable</h3><p>When implementing a signal with the <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">+createSignal:</a> method, the<br>provided block is expected to return a <a href="../../ReactiveCocoa/Objective-C/RACDisposable.h">RACDisposable</a>. This disposable<br>should:</p>
<ul>
<li>As soon as it is convenient, gracefully cancel any in-progress work that was<br>started by the signal.</li>
<li>Immediately dispose of any subscriptions to other signals, thus triggering<br>their cancellation and cleanup code as well.</li>
<li>Release any memory or other resources that were allocated by the signal.</li>
</ul>
<p>This helps fulfill <a href="#disposal-cancels-in-progress-work-and-cleans-up-resources">the RACSignal<br>contract</a>.</p>
<h3 id="Do-not-block-in-an-operator"><a href="#Do-not-block-in-an-operator" class="headerlink" title="Do not block in an operator"></a>Do not block in an operator</h3><p>Stream operators should return a new stream more-or-less immediately. Any work<br>that the operator needs to perform should be part of evaluating the new stream,<br><em>not</em> part of the operator invocation itself.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG!</span></span><br><span class="line">- (RACSequence *)map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span>))block &#123;</span><br><span class="line">    RACSequence *result = [RACSequence empty];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">id</span> mappedObj = block(obj);</span><br><span class="line">        result = [result concat:[RACSequence <span class="keyword">return</span>:mappedObj]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Right!</span></span><br><span class="line">- (RACSequence *)map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span>))block &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> flattenMap:^(<span class="keyword">id</span> obj) &#123;</span><br><span class="line">        <span class="keyword">id</span> mappedObj = block(obj);</span><br><span class="line">        <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:mappedObj];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This guideline can be safely ignored when the purpose of an operator is to<br>synchronously retrieve one or more values from a stream (like<br><a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">-first</a>).</p>
<h3 id="Avoid-stack-overflow-from-deep-recursion"><a href="#Avoid-stack-overflow-from-deep-recursion" class="headerlink" title="Avoid stack overflow from deep recursion"></a>Avoid stack overflow from deep recursion</h3><p>Any operator that might recurse indefinitely should use the<br><code>-scheduleRecursiveBlock:</code> method of <a href="../../ReactiveCocoa/Objective-C/RACScheduler.h">RACScheduler</a>. This method will<br>transform recursion into iteration instead, preventing a stack overflow.</p>
<p>For example, this would be an incorrect implementation of<br><a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">-repeat</a>, due to its potential to overflow the call stack<br>and cause a crash:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)repeat &#123;</span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">        __block <span class="keyword">void</span> (^resubscribe)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            RACDisposable *disposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">                [subscriber sendNext:x];</span><br><span class="line">            &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                [subscriber sendError:error];</span><br><span class="line">            &#125; completed:^&#123;</span><br><span class="line">                resubscribe();</span><br><span class="line">            &#125;];</span><br><span class="line"></span><br><span class="line">            [compoundDisposable addDisposable:disposable];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> compoundDisposable;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>By contrast, this version will avoid a stack overflow:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)repeat &#123;</span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">        RACScheduler *scheduler = RACScheduler.currentScheduler ?: [RACScheduler scheduler];</span><br><span class="line">        RACDisposable *disposable = [scheduler scheduleRecursiveBlock:^(<span class="keyword">void</span> (^reschedule)(<span class="keyword">void</span>)) &#123;</span><br><span class="line">            RACDisposable *disposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">                [subscriber sendNext:x];</span><br><span class="line">            &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                [subscriber sendError:error];</span><br><span class="line">            &#125; completed:^&#123;</span><br><span class="line">                reschedule();</span><br><span class="line">            &#125;];</span><br><span class="line"></span><br><span class="line">            [compoundDisposable addDisposable:disposable];</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        [compoundDisposable addDisposable:disposable];</span><br><span class="line">        <span class="keyword">return</span> compoundDisposable;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Framework-Overview"><a href="#Framework-Overview" class="headerlink" title="Framework Overview"></a>Framework Overview</h1><p>This document contains a high-level description of the different components<br>within the ReactiveCocoa framework, and an attempt to explain how they work<br>together and divide responsibilities. This is meant to be a starting point for<br>learning about new modules and finding more specific documentation.</p>
<p>For examples and help understanding how to use RAC, see the <a href="../../README.md">README</a> or<br>the <a href="DesignGuidelines.md">Design Guidelines</a>.</p>
<h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p>A <strong>stream</strong>, represented by the <a href="../../ReactiveCocoa/Objective-C/RACStream.h">RACStream</a> abstract class, is any series of<br>object values.</p>
<p>Values may be available immediately or in the future, but must be retrieved<br>sequentially. There is no way to retrieve the second value of a stream without<br>evaluating or waiting for the first value.</p>
<p>Streams are <a href="http://en.wikipedia.org/wiki/Monad_(functional_programming)" target="_blank" rel="noopener">monads</a>. Among other things, this allows complex operations to be<br>built on a few basic primitives (<code>-bind:</code> in particular). <a href="../../ReactiveCocoa/Objective-C/RACStream.h">RACStream</a> also<br>implements the equivalent of the <a href="http://downloads.haskell.org/~ghc/latest/docs/html/libraries/Data-Monoid.html" target="_blank" rel="noopener">Monoid</a> and <a href="http://downloads.haskell.org/~ghc/latest/docs/html/libraries/Control-Monad-Zip.html" target="_blank" rel="noopener">MonadZip</a> typeclasses from<br><a href="http://www.haskell.org" target="_blank" rel="noopener">Haskell</a>.</p>
<p><a href="../../ReactiveCocoa/Objective-C/RACStream.h">RACStream</a> isn’t terribly useful on its own. Most streams are treated as<br><a href="#signals">signals</a> or <a href="#sequences">sequences</a> instead.</p>
<h2 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h2><p>A <strong>signal</strong>, represented by the <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a> class, is a <em>push-driven</em><br><a href="#streams">stream</a>.</p>
<p>Signals generally represent data that will be delivered in the future. As work<br>is performed or data is received, values are <em>sent</em> on the signal, which pushes<br>them out to any subscribers. Users must <a href="#subscription">subscribe</a> to a signal<br>in order to access its values.</p>
<p>Signals send three different types of events to their subscribers:</p>
<ul>
<li>The <strong>next</strong> event provides a new value from the stream. <a href="../../ReactiveCocoa/Objective-C/RACStream.h">RACStream</a><br>methods only operate on events of this type. Unlike Cocoa collections, it is<br>completely valid for a signal to include <code>nil</code>.</li>
<li>The <strong>error</strong> event indicates that an error occurred before the signal could<br>finish. The event may include an <code>NSError</code> object that indicates what went<br>wrong. Errors must be handled specially – they are not included in the<br>stream’s values.</li>
<li>The <strong>completed</strong> event indicates that the signal finished successfully, and<br>that no more values will be added to the stream. Completion must be handled<br>specially – it is not included in the stream of values.</li>
</ul>
<p>The lifetime of a signal consists of any number of <code>next</code> events, followed by<br>one <code>error</code> or <code>completed</code> event (but not both).</p>
<h3 id="Subscription-1"><a href="#Subscription-1" class="headerlink" title="Subscription"></a>Subscription</h3><p>A <strong>subscriber</strong> is anything that is waiting or capable of waiting for events<br>from a <a href="#signals">signal</a>. Within RAC, a subscriber is represented as any object<br>that conforms to the <a href="../../ReactiveCocoa/Objective-C/RACSubscriber.h">RACSubscriber</a> protocol.</p>
<p>A <strong>subscription</strong> is created through any call to<br><a href="../../ReactiveCocoa/Objective-C/RACSignal.h">-subscribeNext:error:completed:</a>, or one of the corresponding<br>convenience methods. Technically, most <a href="../../ReactiveCocoa/Objective-C/RACStream.h">RACStream</a> and<br><a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">RACSignal</a> operators create subscriptions as well, but<br>these intermediate subscriptions are usually an implementation detail.</p>
<p>Subscriptions <a href="MemoryManagement.md">retain their signals</a>, and are automatically<br>disposed of when the signal completes or errors. Subscriptions can also be<br><a href="#disposables">disposed of manually</a>.</p>
<h3 id="Subjects"><a href="#Subjects" class="headerlink" title="Subjects"></a>Subjects</h3><p>A <strong>subject</strong>, represented by the <a href="../../ReactiveCocoa/Objective-C/RACSubject.h">RACSubject</a> class, is a <a href="#signals">signal</a><br>that can be manually controlled.</p>
<p>Subjects can be thought of as the “mutable” variant of a signal, much like<br><code>NSMutableArray</code> is for <code>NSArray</code>. They are extremely useful for bridging<br>non-RAC code into the world of signals.</p>
<p>For example, instead of handling application logic in block callbacks, the<br>blocks can simply send events to a shared subject instead. The subject can then<br>be returned as a <a href="../../ReactiveCocoa/Objective-C/RACSignal.h">RACSignal</a>, hiding the implementation detail of the<br>callbacks.</p>
<p>Some subjects offer additional behaviors as well. In particular,<br><a href="../../ReactiveCocoa/Objective-C/RACReplaySubject.h">RACReplaySubject</a> can be used to buffer events for future<br><a href="#subscription">subscribers</a>, like when a network request finishes before<br>anything is ready to handle the result.</p>
<h3 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h3><p>A <strong>command</strong>, represented by the <a href="../../ReactiveCocoa/Objective-C/RACCommand.h">RACCommand</a> class, creates and subscribes<br>to a signal in response to some action. This makes it easy to perform<br>side-effecting work as the user interacts with the app.</p>
<p>Usually the action triggering a command is UI-driven, like when a button is<br>clicked. Commands can also be automatically disabled based on a signal, and this<br>disabled state can be represented in a UI by disabling any controls associated<br>with the command.</p>
<p>On OS X, RAC adds a <code>rac_command</code> property to<br><a href="../../ReactiveCocoa/Objective-C/NSButton+RACCommandSupport.h">NSButton</a> for setting up these behaviors<br>automatically.</p>
<h3 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h3><p>A <strong>connection</strong>, represented by the <a href="../../ReactiveCocoa/Objective-C/RACMulticastConnection.h">RACMulticastConnection</a> class, is<br>a <a href="#subscription">subscription</a> that is shared between any number of<br>subscribers.</p>
<p><a href="#signals">Signals</a> are <em>cold</em> by default, meaning that they start doing work<br><em>each</em> time a new subscription is added. This behavior is usually desirable,<br>because it means that data will be freshly recalculated for each subscriber, but<br>it can be problematic if the signal has side effects or the work is expensive<br>(for example, sending a network request).</p>
<p>A connection is created through the <code>-publish</code> or <code>-multicast:</code> methods on<br><a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">RACSignal</a>, and ensures that only one underlying<br>subscription is created, no matter how many times the connection is subscribed<br>to. Once connected, the connection’s signal is said to be <em>hot</em>, and the<br>underlying subscription will remain active until <em>all</em> subscriptions to the<br>connection are <a href="#disposables">disposed</a>.</p>
<h2 id="Sequences"><a href="#Sequences" class="headerlink" title="Sequences"></a>Sequences</h2><p>A <strong>sequence</strong>, represented by the <a href="../../ReactiveCocoa/Objective-C/RACSequence.h">RACSequence</a> class, is a <em>pull-driven</em><br><a href="#streams">stream</a>.</p>
<p>Sequences are a kind of collection, similar in purpose to <code>NSArray</code>. Unlike<br>an array, the values in a sequence are evaluated <em>lazily</em> (i.e., only when they<br>are needed) by default, potentially improving performance if only part of<br>a sequence is used. Just like Cocoa collections, sequences cannot contain <code>nil</code>.</p>
<p>Sequences are similar to <a href="http://clojure.org/sequences" target="_blank" rel="noopener">Clojure’s sequences</a> (<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/lazy-seq" target="_blank" rel="noopener">lazy-seq</a> in particular), or<br>the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Data-List.html" target="_blank" rel="noopener">List</a> type in <a href="http://www.haskell.org" target="_blank" rel="noopener">Haskell</a>.</p>
<p>RAC adds a <code>-rac_sequence</code> method to most of Cocoa’s collection classes,<br>allowing them to be used as <a href="../../ReactiveCocoa/Objective-C/RACSequence.h">RACSequences</a> instead.</p>
<h2 id="Disposables"><a href="#Disposables" class="headerlink" title="Disposables"></a>Disposables</h2><p>The <strong><a href="../../ReactiveCocoa/Objective-C/RACDisposable.h">RACDisposable</a></strong> class is used for cancellation and resource cleanup.</p>
<p>Disposables are most commonly used to unsubscribe from a <a href="#signals">signal</a>.<br>When a <a href="#subscription">subscription</a> is disposed, the corresponding subscriber<br>will not receive <em>any</em> further events from the signal. Additionally, any work<br>associated with the subscription (background processing, network requests, etc.)<br>will be cancelled, since the results are no longer needed.</p>
<p>For more information about cancellation, see the RAC <a href="DesignGuidelines.md">Design Guidelines</a>.</p>
<h2 id="Schedulers"><a href="#Schedulers" class="headerlink" title="Schedulers"></a>Schedulers</h2><p>A <strong>scheduler</strong>, represented by the <a href="../../ReactiveCocoa/Objective-C/RACScheduler.h">RACScheduler</a> class, is a serial<br>execution queue for <a href="#signals">signals</a> to perform work or deliver their results upon.</p>
<p>Schedulers are similar to Grand Central Dispatch queues, but schedulers support<br>cancellation (via <a href="#disposables">disposables</a>), and always execute serially.<br>With the exception of the <a href="../../ReactiveCocoa/Objective-C/RACScheduler.h">+immediateScheduler</a>, schedulers do not<br>offer synchronous execution. This helps avoid deadlocks, and encourages the use<br>of <a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">signal operators</a> instead of blocking work.</p>
<p><a href="../../ReactiveCocoa/Objective-C/RACScheduler.h">RACScheduler</a> is also somewhat similar to <code>NSOperationQueue</code>, but schedulers<br>do not allow tasks to be reordered or depend on one another.</p>
<h2 id="Value-types"><a href="#Value-types" class="headerlink" title="Value types"></a>Value types</h2><p>RAC offers a few miscellaneous classes for conveniently representing values in<br>a <a href="#streams">stream</a>:</p>
<ul>
<li><strong><a href="../../ReactiveCocoa/Objective-C/RACTuple.h">RACTuple</a></strong> is a small, constant-sized collection that can contain<br><code>nil</code> (represented by <code>RACTupleNil</code>). It is generally used to represent<br>the combined values of multiple streams.</li>
<li><strong><a href="../../ReactiveCocoa/Objective-C/RACUnit.h">RACUnit</a></strong> is a singleton “empty” value. It is used as a value in<br>a stream for those times when more meaningful data doesn’t exist.</li>
<li><strong><a href="../../ReactiveCocoa/Objective-C/RACEvent.h">RACEvent</a></strong> represents any <a href="#signals">signal event</a> as a single value.<br>It is primarily used by the <code>-materialize</code> method of<br><a href="../../ReactiveCocoa/Objective-C/RACSignal+Operations.h">RACSignal</a>.</li>
</ul>
<h1 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h1><p>ReactiveCocoa’s memory management is quite complex, but the end result is that<br><strong>you don’t need to retain signals in order to process them</strong>.</p>
<p>If the framework required you to retain every signal, it’d be much more unwieldy<br>to use, especially for one-shot signals that are used like futures (e.g.,<br>network requests). You’d have to save any long-lived signal into a property, and<br>then also make sure to clear it out when you’re done with it. Not fun.</p>
<h2 id="Subscribers"><a href="#Subscribers" class="headerlink" title="Subscribers"></a>Subscribers</h2><p>Before going any further, it’s worth noting that<br><code>subscribeNext:error:completed:</code> (and all variants thereof) create an <em>implicit</em><br>subscriber using the given blocks. Any objects referenced from those blocks will<br>therefore be retained as part of the subscription. Just like any other object,<br><code>self</code> won’t be retained without a direct or indirect reference to it.</p>
<h2 id="Finite-or-Short-Lived-Signals"><a href="#Finite-or-Short-Lived-Signals" class="headerlink" title="Finite or Short-Lived Signals"></a>Finite or Short-Lived Signals</h2><p>The most important guideline to RAC memory management is that a <strong>subscription<br>is automatically terminated upon completion or error, and the subscriber<br>removed</strong>.</p>
<p>For example, if you have some code like this in your view controller:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.disposable = [signal subscribeCompleted:^&#123;</span><br><span class="line">    doSomethingPossiblyInvolving(<span class="keyword">self</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>… the memory management will look something like the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view controller -&gt; RACDisposable -&gt; RACSignal -&gt; RACSubscriber -&gt; view controller</span><br></pre></td></tr></table></figure>
<p>However, the <code>RACSignal -&gt; RACSubscriber</code> relationship is torn down as soon as<br><code>signal</code> finishes, breaking the retain cycle.</p>
<p><strong>This is often all you need</strong>, because the lifetime of the <code>RACSignal</code> in<br>memory will naturally match the logical lifetime of the event stream.</p>
<h2 id="Infinite-Signals"><a href="#Infinite-Signals" class="headerlink" title="Infinite Signals"></a>Infinite Signals</h2><p>Infinite signals (or signals that live so long that they might as well be<br>infinite), however, will never tear down naturally. This is where disposables<br>shine.</p>
<p><strong>Disposing of a subscription will remove the associated subscriber</strong>, and just<br>generally clean up any resources associated with that subscription. To that one<br>subscriber, it’s just as if the signal had completed or errored, except no final<br>event is sent on the signal. All other subscribers will remain intact.</p>
<p>However, as a general rule of thumb, if you have to manually manage<br>a subscription’s lifecycle, <a href="DesignGuidelines.md#avoid-explicit-subscriptions-and-disposal">there’s probably a better way to do what you want</a>.</p>
<h2 id="Signals-Derived-from-self"><a href="#Signals-Derived-from-self" class="headerlink" title="Signals Derived from self"></a>Signals Derived from <code>self</code></h2><p>There’s still a bit of a tricky middle case here, though. Any time a signal’s<br>lifetime is tied to the calling scope, you’ll have a much harder cycle to break.</p>
<p>This commonly occurs when using <code>RACObserve()</code> on a key<br>path that’s relative to <code>self</code>, and then applying a block that needs to capture<br><code>self</code>.</p>
<p>The easiest answer here is just to <strong>capture <code>self</code> weakly</strong>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[RACObserve(<span class="keyword">self</span>, username) subscribeNext:^(<span class="built_in">NSString</span> *username) &#123;</span><br><span class="line">    <span class="keyword">id</span> strongSelf = weakSelf;</span><br><span class="line">    [strongSelf validateUsername];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>Or, after importing the included<br><a href="https://github.com/jspahrsummers/libextobjc/blob/master/extobjc/EXTScope.h" target="_blank" rel="noopener">EXTScope.h</a><br>header:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">[RACObserve(<span class="keyword">self</span>, username) subscribeNext:^(<span class="built_in">NSString</span> *username) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    [<span class="keyword">self</span> validateUsername];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><em>(Replace <code>__weak</code> or <code>@weakify</code> with <code>__unsafe_unretained</code> or <code>@unsafeify</code>,<br>respectively, if the object doesn’t support weak references.)</em></p>
<p>However, <a href="DesignGuidelines.md#avoid-explicit-subscriptions-and-disposal">there’s probably a better pattern you could use instead</a>. For<br>example, the above sample could perhaps be written like:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(validateUsername:) withSignals:RACObserve(<span class="keyword">self</span>, username), <span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>or:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *validated = [RACObserve(<span class="keyword">self</span>, username) map:^(<span class="built_in">NSString</span> *username) &#123;</span><br><span class="line">    <span class="comment">// Put validation logic here.</span></span><br><span class="line">    <span class="keyword">return</span> @YES;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>As with infinite signals, there are generally ways you can avoid referencing<br><code>self</code> (or any object) from blocks in a signal chain.</p>
<hr>
<p>The above information is really all you should need in order to use<br>ReactiveCocoa effectively. However, there’s one more point to address, just for<br>the technically curious or for anyone interested in contributing to RAC.</p>
<p>The design goal of “no retaining necessary” begs the question: how do we know<br>when a signal should be deallocated? What if it was just created, escaped an<br>autorelease pool, and hasn’t been retained yet?</p>
<p>The real answer is <em>we don’t</em>, BUT we can usually assume that the caller will<br>retain the signal within the current run loop iteration if they want to keep it.</p>
<p>Consequently:</p>
<ol>
<li>A created signal is automatically added to a global set of active signals.</li>
<li>The signal will wait for a single pass of the main run loop, and then remove<br>itself from the active set <em>if it has no subscribers</em>. Unless the signal was<br>retained somehow, it would deallocate at this point.</li>
<li>If something did subscribe in that run loop iteration, the signal stays in<br>the set.</li>
<li>Later, when all the subscribers are gone, step 2 is triggered again.</li>
</ol>
<p>This could backfire if the run loop is spun recursively (like in a modal event<br>loop on OS X), but it makes the life of the framework consumer much easier for<br>most or all other cases.</p>
</div><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/Objective-C/">Objective-C</a><a href="/tags/MVVM/">MVVM</a></div><div class="post-nav"><a class="pre" href="/2016/10/14/SearchADS/">SearchADS</a><a class="next" href="/2016/08/31/二叉树/">二叉树</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/工具/">工具</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/">Objective-C</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/Runtime/">Runtime</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/设计模式/">设计模式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/UIKit/">UIKit</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/xx/">xx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/图像/">图像</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/逆向/">逆向</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/opengl/">opengl</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/php/后端/">后端</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/jQuery/">jQuery</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/后端/redis/">redis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/后端/redis/缓存/">缓存</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像/">图像</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/逆向/" style="font-size: 15px;">逆向</a> <a href="/tags/Objective-C/" style="font-size: 15px;">Objective-C</a> <a href="/tags/图像/" style="font-size: 15px;">图像</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/后端/" style="font-size: 15px;">后端</a> <a href="/tags/搜索广告/" style="font-size: 15px;">搜索广告</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/xx/" style="font-size: 15px;">xx</a> <a href="/tags/Xcode/" style="font-size: 15px;">Xcode</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/视频编解码/" style="font-size: 15px;">视频编解码</a> <a href="/tags/图像质量/" style="font-size: 15px;">图像质量</a> <a href="/tags/打包/" style="font-size: 15px;">打包</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/javaScript/" style="font-size: 15px;">javaScript</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/加密/" style="font-size: 15px;">加密</a> <a href="/tags/计算机基础/" style="font-size: 15px;">计算机基础</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/xcode/" style="font-size: 15px;">xcode</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/UIKit/" style="font-size: 15px;">UIKit</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/Effective-Objective-C-2-0/" style="font-size: 15px;">Effective Objective-C 2.0</a> <a href="/tags/opengl/" style="font-size: 15px;">opengl</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/音视频/" style="font-size: 15px;">音视频</a> <a href="/tags/图片/" style="font-size: 15px;">图片</a> <a href="/tags/动画/" style="font-size: 15px;">动画</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/视频/" style="font-size: 15px;">视频</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/MVVM/" style="font-size: 15px;">MVVM</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/11/RGB与YUV格式转换/">RGB与YUV格式转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/01/颜色/">颜色</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/21/打印堆栈信息，保存现场/">打印堆栈信息，保存现场</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/22/mac-os开启php-Apache-MySQL环境搭建/">mac os开启php+Apache+MySQL环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/flv打包的h-264格式/">flv打包的h.264格式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/NSObject与id的区别/">NSObject与id的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/06/C-虚函数、纯虚函数/">C++虚函数、纯虚函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/22/xcode工程嵌入工程/">xcode工程嵌入工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/21/linux命令备忘-md/">linux命令备忘.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/09/cocoapod库制作/">cocoapod库制作</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>