<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>GCD | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">GCD</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">GCD</h1><div class="post-meta">Jun 15, 2014<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a><a href="/categories/iOS/Objective-C/">Objective-C</a><a href="/categories/iOS/Objective-C/线程/">线程</a></span></div><div class="post-content"><h1 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h1><h2 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h2><p>如果想在dispatch_queue中所有的任务执行完成后在做某种操作，在串行队列中，可以把该操作放到最后一个任务执行完成后继续，但是在并行队列中怎么做呢。这就有dispatch_group 成组操作。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t dispatchQueue = dispatch_queue_create(&quot;ted.queue.next&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_group_t dispatchGroup = dispatch_group_create(); </span><br><span class="line">dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123; </span><br><span class="line">	NSLog(@&quot;dispatch-1&quot;); </span><br><span class="line">&#125;); </span><br><span class="line">dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123;</span><br><span class="line"> 	NSLog(@&quot;dspatch-2&quot;); </span><br><span class="line"> &#125;); </span><br><span class="line"> </span><br><span class="line">dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^()&#123; </span><br><span class="line">	NSLog(@&quot;end&quot;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>还有一个类似功能的接口是： <code>long dispatch_group_wait(dispatch_group_t roup, dispatch_time_t timeout)</code>, timeout参数是超时时间，如果所需的时间小于timeout，则返回0，否则返回非0值。此参数也可以取常量DISPATCH_TIME_FOREVER。这个接口会阻塞当前线程，而 notify不会。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">   dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">   dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC, 0.0 * NSEC_PER_SEC);</span><br><span class="line">   dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">       NSLog(@&quot;now is %@&quot;,[NSDate date]);</span><br><span class="line">       dispatch_source_cancel(timer);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_resume(timer);</span><br></pre></td></tr></table></figure>
<h2 id="自定义队列"><a href="#自定义队列" class="headerlink" title="自定义队列"></a>自定义队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">串行队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;hehehqueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">并行队列：</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;hehehqueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h2><p>是在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行。<br>在并行队列中，有的时候我们需要让某个任务单独执行，也就是他执行的时候不允许其他任务执行。这时候dispatch_barrier就派上了用场。</p>
<p>dispatch_barrier最典型的使用场景是读写问题，NSMutableDictionary在多个线程中如果同时写入，或者一个线程写入一个线程读取，会发生无法预料的错误。但是他可以在多个线程中同时读取。如果多个线程同时使用同一个NSMutableDictionary。怎样才能保护NSMutableDictionary不发生意外呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(id)anObject forKey:(id</span><br><span class="line">)aKey</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async(self.concurrentQueue, ^&#123;</span><br><span class="line">        [self.mutableDictionary setObject:anObject forKey:aKey];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (id)objectForKey:(id)aKey</span><br><span class="line">&#123;</span><br><span class="line">    __block id object = nil;    </span><br><span class="line">    dispatch_sync(self.concurrentQueue, ^&#123;</span><br><span class="line">        object = [self.mutableDictionary objectForKey:aKey];</span><br><span class="line">    &#125;);    return  object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="执行某个代码片段N次"><a href="#执行某个代码片段N次" class="headerlink" title="执行某个代码片段N次"></a>执行某个代码片段N次</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_apply(5, globalQ, ^(size_t index) &#123;</span><br><span class="line">    // 执行5次</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码类似于 <code>for(int i = 0, i &lt; 5; i++)</code>。不同的是，dispatch_apply（）可以用并发队列，并发的来执行里面的块。</p>
<h2 id="set-specific-amp-get-specific-给队列关联内容"><a href="#set-specific-amp-get-specific-给队列关联内容" class="headerlink" title="set_specific &amp; get_specific  给队列关联内容"></a>set_specific &amp; get_specific  给队列关联内容</h2><p>iOS 6之后dispatch_get_current_queue()被废弃，如果我们需要区分不同的queue，可以使用set_specific方法。根据对应的key是否有值来区分。或者有时候我们需要将某些东西关联到队列上，比如我们想在某个队列上存一个东西，或者我们想区分2个队列。GCD提供了dispatch_queue_set_specific方法，通过key，将context关联到queue上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor);</span><br><span class="line"></span><br><span class="line">- queue：需要关联的queue，不允许传入NULL</span><br><span class="line">- key：唯一的关键字</span><br><span class="line">- context：要关联的内容，可以为NULL</span><br><span class="line">- destructor：释放context的函数，当新的context被设置时，destructor会被调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有存就有取，将context关联到queue上之后，可以通过dispatch_queue_get_specific或者dispatch_get_specific方法将值取出来。</span><br><span class="line"></span><br><span class="line">void *dispatch_queue_get_specific(dispatch_queue_t queue, const void *key);</span><br><span class="line"></span><br><span class="line">void *dispatch_get_specific(const void *key);</span><br><span class="line"></span><br><span class="line">dispatch_queue_get_specific: 根据queue和key取出context，queue参数不能传入全局队列</span><br><span class="line"></span><br><span class="line">dispatch_get_specific: 根据唯一的key取出当前queue的context。</span><br><span class="line">如果当前queue没有key对应的context，则去queue的target queue取，取不着返回NULL，如果对全局队列取，也会返回NULL</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-block-t-定义不带参数的回调函数"><a href="#dispatch-block-t-定义不带参数的回调函数" class="headerlink" title="dispatch_block_t 定义不带参数的回调函数"></a>dispatch_block_t 定义不带参数的回调函数</h2><p>之前不带参数的回调函数这样写的：</p>
<p>在.h文件里</p>
<p>定义类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^successBlockAction)();</span><br></pre></td></tr></table></figure>
<p>在.m 文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)onClick:(successBlockAction)successBlock&#123;</span><br><span class="line"></span><br><span class="line">successBlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在使用这个更加方便的方式：</p>
<p>在.h文件里定义一个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,copy) dispatch_block_t succeedBlock;</span><br></pre></td></tr></table></figure>
<p>在.m文件里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UIButton *btn = [[UIButton alloc]init];</span><br><span class="line"></span><br><span class="line">btn.successBlockAction= ^() &#123;</span><br><span class="line"></span><br><span class="line">	NSLog(@&quot; button clicked&quot;);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-source"><a href="#dispatch-source" class="headerlink" title="dispatch source"></a>dispatch source</h2><p>上面提到的 定时器其实就是一个事件源,是一个内置事件源。事件源可以分为自定义事件源和内置事件源</p>
<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1</a></p>
<p><strong>Reading Data from a Descriptor</strong></p>
<p>To read data from a file or socket, you must open the file or socket and create a dispatch source of type DISPATCH_SOURCE_TYPE_READ. The event handler you specify should be capable of reading and processing the contents of the file descriptor. In the case of a file, this amounts to reading the file data (or a subset of that data) and creating the appropriate data structures for your application. For a network socket, this involves processing newly received network data.</p>
<p>Whenever reading data, <code>you should always configure your descriptor to use non-blocking operations</code>. Although you can use the dispatch_source_get_data function to see how much data is available for reading, <strong>the number returned by that function could change between the time you make the call and the time you actually read the data.</strong> If the underlying file is truncated or a network error occurs, reading from a descriptor that blocks the current thread could stall your event handler in mid execution and prevent the dispatch queue from dispatching other tasks. For a serial queue, this could deadlock your queue, and even for a concurrent queue this reduces the number of new tasks that can be started.</p>
<p>Listing 4-2 shows an example that configures a dispatch source to read data from a file. In this example, the event handler reads the entire contents of the specified file into a buffer and calls a custom function (that you would define in your own code) to process the data. (The caller of this function would use the returned dispatch source to cancel it once the read operation was completed.) To ensure that the dispatch queue does not block unnecessarily when there is no data to read, this example uses the fcntl function to configure the file descriptor to perform nonblocking operations. The cancellation handler installed on the dispatch source ensures that the file descriptor is closed after the data is read.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t ProcessContentsOfFile(const char* filename)</span><br><span class="line">&#123;</span><br><span class="line">   // Prepare the file for reading.</span><br><span class="line">   int fd = open(filename, O_RDONLY);</span><br><span class="line">   if (fd == -1)</span><br><span class="line">      return NULL;</span><br><span class="line">   fcntl(fd, F_SETFL, O_NONBLOCK);  // Avoid blocking the read operation</span><br><span class="line"> </span><br><span class="line">   dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">   dispatch_source_t readSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,</span><br><span class="line">                                   fd, 0, queue);</span><br><span class="line">   if (!readSource)</span><br><span class="line">   &#123;</span><br><span class="line">      close(fd);</span><br><span class="line">      return NULL;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // Install the event handler</span><br><span class="line">   dispatch_source_set_event_handler(readSource, ^&#123;</span><br><span class="line">      size_t estimated = dispatch_source_get_data(readSource) + 1;</span><br><span class="line">      // Read the data into a text buffer.</span><br><span class="line">      char* buffer = (char*)malloc(estimated);</span><br><span class="line">      if (buffer)</span><br><span class="line">      &#123;</span><br><span class="line">         ssize_t actual = read(fd, buffer, (estimated));</span><br><span class="line">         Boolean done = MyProcessFileData(buffer, actual);  // Process the data.</span><br><span class="line"> </span><br><span class="line">         // Release the buffer when done.</span><br><span class="line">         free(buffer);</span><br><span class="line"> </span><br><span class="line">         // If there is no more data, cancel the source.</span><br><span class="line">         if (done)</span><br><span class="line">            dispatch_source_cancel(readSource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">   // Install the cancellation handler</span><br><span class="line">   dispatch_source_set_cancel_handler(readSource, ^&#123;close(fd);&#125;);</span><br><span class="line"> </span><br><span class="line">   // Start reading the file.</span><br><span class="line">   dispatch_resume(readSource);</span><br><span class="line">   return readSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="NSOperationqueue"><a href="#NSOperationqueue" class="headerlink" title="NSOperationqueue"></a>NSOperationqueue</h1><p>一个NSOperation对象可以通过调用start方法来执行任务，默认是同步执行的。也可以将NSOperation添加到一个NSOperationQueue(操作队列)中去执行，而且是异步执行的。</p>
<p>注意：NSOperation添加到queue之后,绝对不要再修改NSOperation对象的状态。因为NSOperation对象可能会在任何时候运行,因此改变NSOperation对象的依赖或数据会产生不利的影响。你只能查看NSOperation对象的状态, 比如是否正在运行、等待运行、已经完成等</p>
<h2 id="设置operation之间的依赖关系"><a href="#设置operation之间的依赖关系" class="headerlink" title="设置operation之间的依赖关系"></a>设置operation之间的依赖关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];  </span><br><span class="line">  </span><br><span class="line">NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^()&#123;  </span><br><span class="line">    NSLog(@&quot;执行第1次操作，线程：%@&quot;, [NSThread currentThread]);  </span><br><span class="line">&#125;];  </span><br><span class="line">  </span><br><span class="line">NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^()&#123;  </span><br><span class="line">    NSLog(@&quot;执行第2次操作，线程：%@&quot;, [NSThread currentThread]);  </span><br><span class="line">&#125;];  </span><br><span class="line"> </span><br><span class="line">// operation1依赖于operation2  </span><br><span class="line">[operation1 addDependency:operation2];   </span><br><span class="line"> </span><br><span class="line">[queue addOperation:operation1];  </span><br><span class="line">[queue addOperation:operation2];</span><br></pre></td></tr></table></figure>
<h2 id="修改Operations的执行顺序"><a href="#修改Operations的执行顺序" class="headerlink" title="修改Operations的执行顺序"></a>修改Operations的执行顺序</h2><p>对于添加到queue中的operations，它们的执行顺序取决于2点：</p>
<p>1.首先看看NSOperation是否已经准备好：是否准备好由对象的依赖关系确定</p>
<p>2.然后再根据所有NSOperation的相对优先级来确定。优先级等级则是operation对象本身的一个属性。默认所有operation都拥有“普通”优先级,不过可以通过setQueuePriority:方法来提升或降低operation对象的优先级。优先级只能应用于相同queue中的operations。如果应用有多个operation queue,每个queue的优先级等级是互相独立的。因此不同queue中的低优先级操作仍然可能比高优先级操作更早执行。</p>
<p>注意：优先级不能替代依赖关系,优先级只是对已经准备好的 operations确定执行顺序。先满足依赖关系,然后再根据优先级从所有准备好的操作中选择优先级最高的那个执行。</p>
<h2 id="设置队列的最大并发操作数量"><a href="#设置队列的最大并发操作数量" class="headerlink" title="设置队列的最大并发操作数量"></a>设置队列的最大并发操作数量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 每次只能执行一个操作  </span><br><span class="line">queue.maxConcurrentOperationCount = 1;  </span><br><span class="line">// 或者这样写  </span><br><span class="line">[queue setMaxConcurrentOperationCount:1];</span><br></pre></td></tr></table></figure>
<h2 id="取消Operations"><a href="#取消Operations" class="headerlink" title="取消Operations"></a>取消Operations</h2><p>一旦添加到operation queue,queue就拥有了这个Operation对象并且不能被删除,唯一能做的事情是取消。你可以调用Operation对象的cancel方法取消单个操作,也可以调用operation queue的cancelAllOperations方法取消当前queue中的所有操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 取消单个操作  </span><br><span class="line">[operation cancel];  </span><br><span class="line">  </span><br><span class="line">// 取消queue中所有的操作  </span><br><span class="line">[queue cancelAllOperations];</span><br></pre></td></tr></table></figure>
<h2 id="等待Options完成"><a href="#等待Options完成" class="headerlink" title="等待Options完成"></a>等待Options完成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 会阻塞当前线程，等到某个operation执行完毕  </span><br><span class="line">[operation waitUntilFinished]; </span><br><span class="line"></span><br><span class="line">// 阻塞当前线程，等待queue的所有操作执行完毕  </span><br><span class="line">[queue waitUntilAllOperationsAreFinished];</span><br></pre></td></tr></table></figure>
<h2 id="暂停和继续线程"><a href="#暂停和继续线程" class="headerlink" title="暂停和继续线程"></a>暂停和继续线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 暂停queue  </span><br><span class="line">[queue setSuspended:YES];  </span><br><span class="line">  </span><br><span class="line">// 继续queue  </span><br><span class="line">[queue setSuspended:NO];</span><br></pre></td></tr></table></figure>
<h1 id="两种方式的对比"><a href="#两种方式的对比" class="headerlink" title="两种方式的对比"></a>两种方式的对比</h1><p>GCD仅仅支持FIFO队列，而NSOperationQueue中的队列可以被重新设置优先级，从而实现不同操作的执行顺序调整。<br>GCD不支持异步操作之间的依赖关系设置。如果某个操作的依赖另一个操作的数据（生产者-消费者模型是其中之一），使用NSOperationQueue能够按照正确的顺序执行操作。GCD则没有内建的依赖关系支持。<br>NSOperationQueue支持KVO，意味着我们可以观察任务的执行状态。</p>
<ul>
<li>GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择；</li>
<li>在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)；</li>
<li>NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者会直到后者执行完毕后再执行；</li>
<li>我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或取消，这样子能比GCD更加有效地掌控我们执行的后台任务；</li>
<li>在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码；</li>
<li>我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。</li>
</ul>
<p>总的来说，Operation queue 提供了更多你在编写多线程程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口。从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。</p>
</div><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/线程/">线程</a></div><div class="post-nav"><a class="pre" href="/2014/07/14/NSURLSessionTask/">NSURLSession</a><a class="next" href="/2014/05/09/bridge-bridge-transfer-bridge-retained/">__bridge,__bridge_transfer,__bridge_retained</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/工具/">工具</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/">Objective-C</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/Runtime/">Runtime</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/设计模式/">设计模式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/UIKit/">UIKit</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/xx/">xx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/图像/">图像</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/逆向/">逆向</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/opengl/">opengl</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/php/后端/">后端</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/jQuery/">jQuery</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/后端/redis/">redis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/后端/redis/缓存/">缓存</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像/">图像</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/逆向/" style="font-size: 15px;">逆向</a> <a href="/tags/Objective-C/" style="font-size: 15px;">Objective-C</a> <a href="/tags/图像/" style="font-size: 15px;">图像</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/后端/" style="font-size: 15px;">后端</a> <a href="/tags/搜索广告/" style="font-size: 15px;">搜索广告</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/xx/" style="font-size: 15px;">xx</a> <a href="/tags/Xcode/" style="font-size: 15px;">Xcode</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/视频编解码/" style="font-size: 15px;">视频编解码</a> <a href="/tags/图像质量/" style="font-size: 15px;">图像质量</a> <a href="/tags/打包/" style="font-size: 15px;">打包</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/javaScript/" style="font-size: 15px;">javaScript</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/加密/" style="font-size: 15px;">加密</a> <a href="/tags/计算机基础/" style="font-size: 15px;">计算机基础</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/xcode/" style="font-size: 15px;">xcode</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/UIKit/" style="font-size: 15px;">UIKit</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/Effective-Objective-C-2-0/" style="font-size: 15px;">Effective Objective-C 2.0</a> <a href="/tags/opengl/" style="font-size: 15px;">opengl</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/音视频/" style="font-size: 15px;">音视频</a> <a href="/tags/图片/" style="font-size: 15px;">图片</a> <a href="/tags/动画/" style="font-size: 15px;">动画</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/视频/" style="font-size: 15px;">视频</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/MVVM/" style="font-size: 15px;">MVVM</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/11/RGB与YUV格式转换/">RGB与YUV格式转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/01/颜色/">颜色</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/21/打印堆栈信息，保存现场/">打印堆栈信息，保存现场</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/22/mac-os开启php-Apache-MySQL环境搭建/">mac os开启php+Apache+MySQL环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/flv打包的h-264格式/">flv打包的h.264格式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/NSObject与id的区别/">NSObject与id的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/06/C-虚函数、纯虚函数/">C++虚函数、纯虚函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/22/xcode工程嵌入工程/">xcode工程嵌入工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/21/linux命令备忘-md/">linux命令备忘.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/09/cocoapod库制作/">cocoapod库制作</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>