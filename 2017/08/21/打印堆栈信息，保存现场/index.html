<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Hexo</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-meta">Aug 21, 2017</div><div class="post-content"><p>title: 打印堆栈信息，保存崩溃现场<br>date: 2017-01-31 13:11:57<br>tags: [iOS]</p>
<p>程序崩溃的时候需要上报崩溃堆栈，以及每个线程的堆栈信息。方便查找bug</p>
<h2 id="如何捕获崩溃"><a href="#如何捕获崩溃" class="headerlink" title="如何捕获崩溃"></a>如何捕获崩溃</h2><h3 id="NSSetUncaughtExceptionHandler"><a href="#NSSetUncaughtExceptionHandler" class="headerlink" title="NSSetUncaughtExceptionHandler"></a>NSSetUncaughtExceptionHandler</h3><p>注册 catchCrash 异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">	InstallUncaughtExceptionHandler();//信号量截断</span><br><span class="line">	//注册消息处理函数的处理方法  </span><br><span class="line">	 NSSetUncaughtExceptionHandler(&amp;uncaughtExceptionHandler);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void uncaughtExceptionHandler(NSException *exception)  </span><br><span class="line">&#123;  </span><br><span class="line"> // 异常的堆栈信息  </span><br><span class="line"> NSArray *stackArray = [exception callStackSymbols];  </span><br><span class="line"> // 出现异常的原因  </span><br><span class="line"> NSString *reason = [exception reason];  </span><br><span class="line"> // 异常名称  </span><br><span class="line"> NSString *name = [exception name];  </span><br><span class="line"> NSString *exceptionInfo = [NSString stringWithFormat:@&quot;Exception reason：%@\nException name：%@\nException stack：%@&quot;,name, reason, stackArray];  </span><br><span class="line"> NSLog(@&quot;%@&quot;, exceptionInfo);  </span><br><span class="line"></span><br><span class="line"> NSMutableArray *tmpArr = [NSMutableArray arrayWithArray:stackArray];  </span><br><span class="line"> [tmpArr insertObject:reason atIndex:0];  </span><br><span class="line"></span><br><span class="line"> //保存到本地  --  当然你可以在下次启动的时候，上传这个log  </span><br><span class="line"> [exceptionInfo writeToFile:[NSString stringWithFormat:@&quot;%@/Documents/error.log&quot;,NSHomeDirectory()]  atomically:YES encoding:NSUTF8StringEncoding error:nil];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>NSSetUncaughtExceptionHandler 用来做异常处理，但功能非常有限.这仅仅是捕获一般的OC异常信息，对于Signal异常信号我们仍然无法捕获到。</p>
<p>而引起崩溃的大多数原因如：内存访问错误，重复释放等错误就无能为力了，因为这种错误它抛出的是Signal，所以必须要专门做Signal处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//注意： SignalHandler不要在debug环境下测试。因为系统的debug会优先去拦截。</span><br><span class="line">void InstallUncaughtExceptionHandler()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	 // signal的类型在signal.h的头文件里有详细的列表。</span><br><span class="line">	 //调用abort函数生成的信号。</span><br><span class="line">	 signal(SIGABRT, signalHandler);</span><br><span class="line">	 //执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。</span><br><span class="line">	 signal(SIGILL, signalHandler);</span><br><span class="line">	 //试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.	 signal(SIGSEGV, signalHandler);</span><br><span class="line">	 //在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。</span><br><span class="line">	 signal(SIGFPE, signalHandler);</span><br><span class="line">	 //非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。</span><br><span class="line">	 signal(SIGBUS, signalHandler);</span><br><span class="line">	 //管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。</span><br><span class="line">	 signal(SIGPIPE, signalHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void signalHandler(int signal)</span><br><span class="line">&#123;</span><br><span class="line">	NSMutableString *mstr = [[NSMutableString alloc] init];</span><br><span class="line">	[mstr appendString:@&quot;Stack:\n&quot;];</span><br><span class="line">	void* callback[128];</span><br><span class="line">	int i, frames = backtrace(callstack,128);</span><br><span class="line">	char** strs = backtrace_symbols(callstack, frames);</span><br><span class="line">	for (i = 0; i &lt; frames; ++i)&#123;</span><br><span class="line">		[mstr appendFormat:@&quot;%s\n&quot;,strs[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	NSLog(@&quot;%@&quot;,mstr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="崩溃后获取线程的信息"><a href="#崩溃后获取线程的信息" class="headerlink" title="崩溃后获取线程的信息"></a>崩溃后获取线程的信息</h2><h3 id="首先是要通过-task-threads-取到所有的线程"><a href="#首先是要通过-task-threads-取到所有的线程" class="headerlink" title="首先是要通过 task_threads 取到所有的线程"></a>首先是要通过 task_threads 取到所有的线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread_act_array_t threads; //int 组成的数组比如 thread[1] = 5635</span><br><span class="line">mach_msg_type_number_t thread_count = 0; //mach_msg_type_number_t 是 int 类型</span><br><span class="line">const task_t this_task = mach_task_self(); //int</span><br><span class="line">//根据当前 task 获取所有线程</span><br><span class="line">kern_return_t kr = task_threads(this_task, &amp;threads, &amp;thread_count);</span><br></pre></td></tr></table></figure>
<h3 id="遍历时通过-thread-info-获取各个线程的详细信息"><a href="#遍历时通过-thread-info-获取各个线程的详细信息" class="headerlink" title="遍历时通过 thread_info 获取各个线程的详细信息"></a>遍历时通过 thread_info 获取各个线程的详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SMThreadInfoStruct threadInfoSt = &#123;0&#125;;</span><br><span class="line">thread_info_data_t threadInfo;</span><br><span class="line">thread_basic_info_t threadBasicInfo;</span><br><span class="line">mach_msg_type_number_t threadInfoCount = THREAD_INFO_MAX;</span><br><span class="line">if (thread_info((thread_act_t)thread, THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) == KERN_SUCCESS) &#123;</span><br><span class="line">    threadBasicInfo = (thread_basic_info_t)threadInfo;</span><br><span class="line">    if (!(threadBasicInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">        threadInfoSt.cpuUsage = threadBasicInfo-&gt;cpu_usage / 10;</span><br><span class="line">        threadInfoSt.userTime = threadBasicInfo-&gt;system_time.microseconds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">uintptr_t buffer[100];</span><br><span class="line">int i = 0;</span><br><span class="line">NSMutableString *reStr = [NSMutableString stringWithFormat:@&quot;Stack of thread: %u:\n CPU used: %.1f percent\n user time: %d second\n&quot;, thread, threadInfoSt.cpuUsage, threadInfoSt.userTime];</span><br></pre></td></tr></table></figure>
<h3 id="可以通过-thread-get-state-得到-machine-context-里面包含了线程栈里所有的栈指针。"><a href="#可以通过-thread-get-state-得到-machine-context-里面包含了线程栈里所有的栈指针。" class="headerlink" title="可以通过 thread_get_state 得到 machine context 里面包含了线程栈里所有的栈指针。"></a>可以通过 thread_get_state 得到 machine context 里面包含了线程栈里所有的栈指针。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_STRUCT_MCONTEXT machineContext; //线程栈里所有的栈指针</span><br><span class="line">//通过 thread_get_state 获取完整的 machineContext 信息，包含 thread 状态信息</span><br><span class="line">mach_msg_type_number_t state_count = smThreadStateCountByCPU();</span><br><span class="line">kern_return_t kr = thread_get_state(thread, smThreadStateByCPU(), (thread_state_t)&amp;machineContext.__ss, &amp;state_count);</span><br></pre></td></tr></table></figure>
<h3 id="创建一个栈结构体用来保存栈的数据"><a href="#创建一个栈结构体用来保存栈的数据" class="headerlink" title="创建一个栈结构体用来保存栈的数据"></a>创建一个栈结构体用来保存栈的数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//为通用回溯设计结构支持栈地址由小到大，地址里存储上个栈指针的地址</span><br><span class="line">typedef struct SMStackFrame &#123;</span><br><span class="line">    const struct SMStackFrame *const previous;</span><br><span class="line">    const uintptr_t return_address;</span><br><span class="line">&#125; SMStackFrame;</span><br><span class="line">SMStackFrame stackFrame = &#123;0&#125;;</span><br><span class="line">//通过栈基址指针获取当前栈帧地址</span><br><span class="line">const uintptr_t framePointer = smMachStackBasePointerByCPU(&amp;machineContext);</span><br><span class="line">if (framePointer == 0 || smMemCopySafely((void *)framePointer, &amp;stackFrame, sizeof(stackFrame)) != KERN_SUCCESS) &#123;</span><br><span class="line">    return @&quot;Fail frame pointer&quot;;</span><br><span class="line">&#125;</span><br><span class="line">for (; i &lt; 32; i++) &#123;</span><br><span class="line">    buffer[i] = stackFrame.return_address;</span><br><span class="line">    if (buffer[i] == 0 || stackFrame.previous == 0 || smMemCopySafely(stackFrame.previous, &amp;stackFrame, sizeof(stackFrame)) != KERN_SUCCESS) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="符号化"><a href="#符号化" class="headerlink" title="符号化"></a>符号化</h3><p>符号化主要思想就是通过栈指针地址减去 Slide 地址得到 ASLR 偏移量，通过这个偏移量可以在 __LINKEDIT segment 查找到字符串和符号表的位置。具体代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">info-&gt;dli_fname = NULL;</span><br><span class="line">info-&gt;dli_fbase = NULL;</span><br><span class="line">info-&gt;dli_sname = NULL;</span><br><span class="line">info-&gt;dli_saddr = NULL;</span><br><span class="line">//根据地址获取是哪个 image</span><br><span class="line">const uint32_t idx = smDyldImageIndexFromAddress(address);</span><br><span class="line">if (idx == UINT_MAX) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> Header</span><br><span class="line"> ------------------</span><br><span class="line"> Load commands</span><br><span class="line"> Segment command 1 -------------|</span><br><span class="line"> Segment command 2              |</span><br><span class="line"> ------------------             |</span><br><span class="line"> Data                           |</span><br><span class="line"> Section 1 data |segment 1 &lt;----|</span><br><span class="line"> Section 2 data |          &lt;----|</span><br><span class="line"> Section 3 data |          &lt;----|</span><br><span class="line"> Section 4 data |segment 2</span><br><span class="line"> Section 5 data |</span><br><span class="line"> ...            |</span><br><span class="line"> Section n data |</span><br><span class="line"> */</span><br><span class="line">/*----------Mach Header---------*/</span><br><span class="line">//根据 image 的序号获取 mach_header</span><br><span class="line">const struct mach_header* machHeader = _dyld_get_image_header(idx);</span><br><span class="line">//返回 image_index 索引的 image 的虚拟内存地址 slide 的数量，如果 image_index 超出范围返回0</span><br><span class="line">//动态链接器加载 image 时，image 必须映射到未占用地址的进程的虚拟地址空间。动态链接器通过添加一个值到 image 的基地址来实现，这个值是虚拟内存 slide 数量</span><br><span class="line">const uintptr_t imageVMAddressSlide = (uintptr_t)_dyld_get_image_vmaddr_slide(idx);</span><br><span class="line">/*-----------ASLR 的偏移量---------*/</span><br><span class="line">//https://en.wikipedia.org/wiki/Address_space_layout_randomization</span><br><span class="line">const uintptr_t addressWithSlide = address - imageVMAddressSlide;</span><br><span class="line">//根据 Image 的 Index 来获取 segment 的基地址</span><br><span class="line">//段定义Mach-O文件中的字节范围以及动态链接器加载应用程序时这些字节映射到虚拟内存中的地址和内存保护属性。 因此，段总是虚拟内存页对齐。 片段包含零个或多个节。</span><br><span class="line">const uintptr_t segmentBase = smSegmentBaseOfImageIndex(idx) + imageVMAddressSlide;</span><br><span class="line">if (segmentBase == 0) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">info-&gt;dli_fname = _dyld_get_image_name(idx);</span><br><span class="line">info-&gt;dli_fbase = (void*)machHeader;</span><br><span class="line">/*--------------Mach Segment-------------*/</span><br><span class="line">//地址最匹配的symbol</span><br><span class="line">const nlistByCPU* bestMatch = NULL;</span><br><span class="line">uintptr_t bestDistance = ULONG_MAX;</span><br><span class="line">uintptr_t cmdPointer = smCmdFirstPointerFromMachHeader(machHeader);</span><br><span class="line">if (cmdPointer == 0) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">//遍历每个 segment 判断目标地址是否落在该 segment 包含的范围里</span><br><span class="line">for (uint32_t iCmd = 0; iCmd &lt; machHeader-&gt;ncmds; iCmd++) &#123;</span><br><span class="line">    const struct load_command* loadCmd = (struct load_command*)cmdPointer;</span><br><span class="line">    /*----------目标 Image 的符号表----------*/</span><br><span class="line">    //Segment 除了 __TEXT 和 __DATA 外还有 __LINKEDIT segment，它里面包含动态链接器的使用的原始数据，比如符号，字符串和重定位表项。</span><br><span class="line">    //LC_SYMTAB 描述了 __LINKEDIT segment 内查找字符串和符号表的位置</span><br><span class="line">    if (loadCmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">        //获取字符串和符号表的虚拟内存偏移量。</span><br><span class="line">        const struct symtab_command* symtabCmd = (struct symtab_command*)cmdPointer;</span><br><span class="line">        const nlistByCPU* symbolTable = (nlistByCPU*)(segmentBase + symtabCmd-&gt;symoff);</span><br><span class="line">        const uintptr_t stringTable = segmentBase + symtabCmd-&gt;stroff;</span><br><span class="line">        </span><br><span class="line">        for (uint32_t iSym = 0; iSym &lt; symtabCmd-&gt;nsyms; iSym++) &#123;</span><br><span class="line">            //如果 n_value 是0，symbol 指向外部对象</span><br><span class="line">            if (symbolTable[iSym].n_value != 0) &#123;</span><br><span class="line">                //给定的偏移量是文件偏移量，减去 __LINKEDIT segment 的文件偏移量获得字符串和符号表的虚拟内存偏移量</span><br><span class="line">                uintptr_t symbolBase = symbolTable[iSym].n_value;</span><br><span class="line">                uintptr_t currentDistance = addressWithSlide - symbolBase;</span><br><span class="line">                //寻找最小的距离 bestDistance，因为 addressWithSlide 是某个方法的指令地址，要大于这个方法的入口。</span><br><span class="line">                //离 addressWithSlide 越近的函数入口越匹配</span><br><span class="line">                if ((addressWithSlide &gt;= symbolBase) &amp;&amp; (currentDistance &lt;= bestDistance)) &#123;</span><br><span class="line">                    bestMatch = symbolTable + iSym;</span><br><span class="line">                    bestDistance = currentDistance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bestMatch != NULL) &#123;</span><br><span class="line">            //将虚拟内存偏移量添加到 __LINKEDIT segment 的虚拟内存地址可以提供字符串和符号表的内存 address。</span><br><span class="line">            info-&gt;dli_saddr = (void*)(bestMatch-&gt;n_value + imageVMAddressSlide);</span><br><span class="line">            info-&gt;dli_sname = (char*)((intptr_t)stringTable + (intptr_t)bestMatch-&gt;n_un.n_strx);</span><br><span class="line">            if (*info-&gt;dli_sname == &apos;_&apos;) &#123;</span><br><span class="line">                info-&gt;dli_sname++;</span><br><span class="line">            &#125;</span><br><span class="line">            //所有的 symbols 的已经被处理好了</span><br><span class="line">            if (info-&gt;dli_saddr == info-&gt;dli_fbase &amp;&amp; bestMatch-&gt;n_type == 3) &#123;</span><br><span class="line">                info-&gt;dli_sname = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cmdPointer += loadCmd-&gt;cmdsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2017/09/01/颜色/">颜色</a><a class="next" href="/2017/05/22/mac-os开启php-Apache-MySQL环境搭建/">mac os开启php+Apache+MySQL环境搭建</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/工具/">工具</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/">Objective-C</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/Runtime/">Runtime</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/设计模式/">设计模式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/UIKit/">UIKit</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/xx/">xx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/图像/">图像</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/逆向/">逆向</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/opengl/">opengl</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/php/后端/">后端</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/jQuery/">jQuery</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/后端/redis/">redis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/后端/redis/缓存/">缓存</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像/">图像</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/Objective-C/" style="font-size: 15px;">Objective-C</a> <a href="/tags/图像/" style="font-size: 15px;">图像</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/后端/" style="font-size: 15px;">后端</a> <a href="/tags/搜索广告/" style="font-size: 15px;">搜索广告</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/xx/" style="font-size: 15px;">xx</a> <a href="/tags/Xcode/" style="font-size: 15px;">Xcode</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/视频编解码/" style="font-size: 15px;">视频编解码</a> <a href="/tags/图像质量/" style="font-size: 15px;">图像质量</a> <a href="/tags/打包/" style="font-size: 15px;">打包</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/javaScript/" style="font-size: 15px;">javaScript</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/逆向/" style="font-size: 15px;">逆向</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/加密/" style="font-size: 15px;">加密</a> <a href="/tags/计算机基础/" style="font-size: 15px;">计算机基础</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/UIKit/" style="font-size: 15px;">UIKit</a> <a href="/tags/xcode/" style="font-size: 15px;">xcode</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/Effective-Objective-C-2-0/" style="font-size: 15px;">Effective Objective-C 2.0</a> <a href="/tags/opengl/" style="font-size: 15px;">opengl</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/音视频/" style="font-size: 15px;">音视频</a> <a href="/tags/图片/" style="font-size: 15px;">图片</a> <a href="/tags/动画/" style="font-size: 15px;">动画</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/视频/" style="font-size: 15px;">视频</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/MVVM/" style="font-size: 15px;">MVVM</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/11/RGB与YUV格式转换/">RGB与YUV格式转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/01/颜色/">颜色</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/21/打印堆栈信息，保存现场/">打印堆栈信息，保存现场</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/22/mac-os开启php-Apache-MySQL环境搭建/">mac os开启php+Apache+MySQL环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/flv打包的h-264格式/">flv打包的h.264格式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/NSObject与id的区别/">NSObject与id的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/06/C-虚函数、纯虚函数/">C++虚函数、纯虚函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/22/xcode工程嵌入工程/">xcode工程嵌入工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/21/linux命令备忘-md/">linux命令备忘.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/09/cocoapod库制作/">cocoapod库制作</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>