<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>runtime 一、objc_msgSend消息详解 | 格物致知</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">runtime 一、objc_msgSend消息详解</h1><a id="logo" href="/.">格物致知</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">runtime 一、objc_msgSend消息详解</h1><div class="post-meta">Nov 24, 2015<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a><a href="/categories/iOS/Objective-C/">Objective-C</a><a href="/categories/iOS/Objective-C/Runtime/">Runtime</a></span></div><div class="post-content"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/kesalin/article/details/6689226" target="_blank" rel="noopener">1、罗朝辉 深入浅出 Cocoa 之消息</a><br><a href="http://ios.jobbole.com/81657/" target="_blank" rel="noopener">2、Objective-C 中的元类（meta class）是什么？</a><br><a href="http://ui.ptlogin2.qq.com/cgi-bin/login?low_login=1&amp;appid=603049403&amp;s_url=http%3A%2F%2Fbugly.qq.com%2Fblog%2F%3Fp%3D64&amp;daid=276" target="_blank" rel="noopener">3、小萝莉说crash</a></p>
<h1 id="基本概念与原理"><a href="#基本概念与原理" class="headerlink" title="基本概念与原理"></a>基本概念与原理</h1><p>##Class<br>Class 在objc/objc.h中的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<h2 id="objc-class的结构"><a href="#objc-class的结构" class="headerlink" title="objc_class的结构"></a>objc_class的结构</h2><p>Class 被定义为一个指向 objc_class的结构体指针，这个结构体表示每一个类的类结构。而 objc_class 在objc/objc_class.h中定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    struct objc_class * isa; //类指针（类是元类的对象）</span><br><span class="line">    struct objc_class * super_class;  /*父类*/</span><br><span class="line">    const char *name;                 /*类名字*/</span><br><span class="line">    long version;                   /*版本信息*/</span><br><span class="line">    long info;                        /*类信息*/</span><br><span class="line">    long instance_size;               /*实例大小*/</span><br><span class="line">    struct objc_ivar_list *ivars;     /*实例参数链表*/</span><br><span class="line">    struct objc_method_list **methodLists;  /*方法链表*/</span><br><span class="line">    struct objc_cache *cache;               /*方法缓存*/</span><br><span class="line">    struct objc_protocol_list *protocols;   /*协议链表*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个对象都有类。这是面向对象的基本概念，但是在Objective-C中，它对数据结构也一样。含有一个指针且该指针可以正确指向类的数据结构，都可以被视作为对象。<br>在Objective-C中，对象的类是isa指针决定的。isa指针指向对象所属的类。</p>
<h2 id="objc-msgSend对这个Class结构的应用："><a href="#objc-msgSend对这个Class结构的应用：" class="headerlink" title="objc_msgSend对这个Class结构的应用："></a>objc_msgSend对这个Class结构的应用：</h2><p>objc_msgSend方法含有两个必要的参数：receiver、方法名（即：selector），如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">［receiver message］；将被转换为：objc_msgSend(receiver,selector);</span><br></pre></td></tr></table></figure>
<p>objc_msgSend方法也能传message的参数，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2, …);</span><br></pre></td></tr></table></figure>
<p>objc_msgSend调用类方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL isSuccess = ((BOOL(*)(id,SEL,int))objc_msgSend)(NSClassFromString(@&quot;MyPointsManager&quot;),NSSelectorFromString(@&quot;addPointsIn:&quot;),50);</span><br></pre></td></tr></table></figure>
<p>objc_msgSend调用实例方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyPointsManager *pointsManager = [MyPointsManager sharedInstance];</span><br><span class="line">    BOOL isEnabled = ((BOOL(*)(id,SEL))objc_msgSend)(pointsManager,NSSelectorFromString(@&quot;isEnable&quot;));</span><br><span class="line">    NSLog(@&quot;isEnabled %d&quot;,isEnabled);</span><br></pre></td></tr></table></figure>
<h3 id="objc-msgSend调用类方法跟实例方法的调用实现区别："><a href="#objc-msgSend调用类方法跟实例方法的调用实现区别：" class="headerlink" title="objc_msgSend调用类方法跟实例方法的调用实现区别："></a>objc_msgSend调用类方法跟实例方法的调用实现区别：</h3><h4 id="在oc里，-号函数和-号函数的区别："><a href="#在oc里，-号函数和-号函数的区别：" class="headerlink" title="在oc里，+号函数和-号函数的区别："></a>在oc里，+号函数和-号函数的区别：</h4><p>-(void)是实例方法，只有定义了这个类的实例，才能用实例调用这个方法。<br>+(void)是类方法，用类名可以直接调用这个方法。<br>通过分析，+号函数是基类调用的，-号函数是实例类调用的。其函数结构体数组的位置也不一样。 </p>
<h4 id="1、实例方法调用："><a href="#1、实例方法调用：" class="headerlink" title="1、实例方法调用："></a>1、实例方法调用：</h4><p>每个对象都有一个指向所属类的指针<code>isa</code>。通过该指针，对象可以找到它所属的类，也就找到了其全部父类。当向一个对象发送消息时，objc_msgSend方法根据对象的isa指针找到对象的类，然后在类的<code>调度表（dispatch table）</code>中查找selector。如果无法找到selector，objc_msgSend通过指向父类的指针找到父类，并在父类的调度表（dispatch table）中查找selector，以此类推直到NSObject类。一旦查找到selector，<code>objc_msgSend方法根据调度表的内存地址调用该实现</code>。 通过这种方式，message与方法的真正实现在执行阶段才绑定。<br>为了保证消息发送与执行的效率，系统会将全部selector和使用过的方法的内存地址缓存起来。<code>每个类都有一个独立的缓存，缓存包含有当前类自己的 selector以及继承自父类的selector</code>。查找调度表（dispatch table）前，消息发送系统首先检查receiver对象的缓存。</p>
<h4 id="2、类方法的调用："><a href="#2、类方法的调用：" class="headerlink" title="2、类方法的调用："></a>2、类方法的调用：</h4><p>从Class的结构可以看出，Class中也有一个isa指针，指向实现它的类，即<a href="http://ios.jobbole.com/81657/" target="_blank" rel="noopener">元类（metaClass）</a>。Objective-C中的每个类都有和自己相关的元类，类方法就是放在元类的函数指针数组中。元类也是一个对象，那么元类又指向哪里呢？为了设计上的完整，所有的元类的isa指针都会指向一个根元类。元类的继承关系跟类的继承关系是一样的。</p>
<p>简单说就是：<br>当你给对象发送消息时，消息是在寻找这个对象的类的方法列表。<br>当你给类发消息时，消息是在寻找这个类的元类的方法列表。</p>
<h2 id="objc-class结构里面的方法链表的Method结构"><a href="#objc-class结构里面的方法链表的Method结构" class="headerlink" title="objc_class结构里面的方法链表的Method结构"></a>objc_class结构里面的方法链表的Method结构</h2><p> Method 在头文件 objc_class.h中定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br><span class="line">typedef struct objc_ method &#123;</span><br><span class="line">    SEL method_name;</span><br><span class="line">    char *method_types;</span><br><span class="line">    IMP method_imp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个方法 Method，其包含一个方法选标 SEL – 表示该方法的名称，一个types – 表示该方法参数的类型，一个 IMP  - 指向该方法的具体实现的函数指针</p>
<h2 id="Method结构中SEL的含义"><a href="#Method结构中SEL的含义" class="headerlink" title="Method结构中SEL的含义"></a>Method结构中SEL的含义</h2><p>SEL在objc/objc.h中的定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector   *SEL;</span><br></pre></td></tr></table></figure>
<p>它是一个指向 objc_selector 指针，表示方法的名字/签名。<br>不同的类可以拥有相同的 selector，这个没有问题，因为不同类的实例对象performSelector相同的 selector 时，会在各自的消息选标(selector)/实现地址(address) 方法链表中根据 selector 去查找具体的方法实现IMP, 然后用这个方法实现去执行具体的实现代码。这是一个动态绑定的过程，在编译的时候，我们不知道最终会执行哪一些代码，只有在执行的时候，通过selector去查询，我们才能确定具体的执行代码。</p>
<h2 id="Method结构中的IMP-的含义"><a href="#Method结构中的IMP-的含义" class="headerlink" title="Method结构中的IMP 的含义"></a>Method结构中的IMP 的含义</h2><p>IMP在objc／objc.h中的定义为：<br>typedef id (*IMP)(id, SEL, …);</p>
<p>IMP 是一个函数指针，这个被指向的函数包含一个接收消息的对象id(self  指针), 调用方法的选标 SEL (方法名)，以及不定个数的方法参数，并返回一个id。也就是说 IMP 是消息最终调用的执行代码，是方法真正的实现代码 。我们可以像在Ｃ语言里面一样使用这个函数指针。</p>
<p>NSObject 类中的methodForSelector：方法就是这样一个获取指向方法实现IMP 的指针，methodForSelector：返回的指针和赋值的变量类型必须完全一致，包括方法的参数类型和返回值类型。</p>
<p>下面的例子展示了怎么使用指针来调用setFilled:的方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line">setter = (void(*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];</span><br><span class="line">for (i = 0; i &lt; 1000; i++)</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure>
<h2 id="查找IMP的过程"><a href="#查找IMP的过程" class="headerlink" title="查找IMP的过程"></a>查找IMP的过程</h2><p>说objc_class结构的时候说过，objc_msgSend 会根据方法选标 SEL 在类结构的方法列表中查找方法实现IMP。这里头有一些文章，我们在前面的类结构中也看到有一个叫objc_cache *cache 的成员，这个缓存为提高效率而存在的。每个类都有一个独立的缓存，同时包括继承的方法和在该类中定义的方法。。</p>
<p>下面这段是苹果官方的运行时源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static Method look_up_method(Class cls, SEL sel,   </span><br><span class="line">                             BOOL withCache, BOOL withResolver)  </span><br><span class="line">&#123;  </span><br><span class="line">    Method meth = NULL; </span><br><span class="line">    if (withCache) &#123;  </span><br><span class="line">        meth = _cache_getMethod(cls, sel, &amp;_objc_msgForward_internal);  </span><br><span class="line">        if (meth == (Method)1) &#123;  </span><br><span class="line">            // Cache contains forward:: . Stop searching.  </span><br><span class="line">            return NULL;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (!meth) meth = _class_getMethod(cls, sel);  </span><br><span class="line">    if (!meth  &amp;&amp;  withResolver) meth = _class_resolveMethod(cls, sel); </span><br><span class="line">    return meth;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上面的源代码可以看出：<br>1、首先去该类的方法 cache中查找，如果找到了就返回它；<br>2、如果没有找到，就去该类的方法列表中查找。如果在该类的方法列表中找到了，则将 IMP返回，并将它加入cache中缓存起来。根据最近使用原则，这个方法再次调用的可能性很大，缓存起来可以节省下次调用再次查找的开销。<br>3、如果在该类的方法列表中没找到对应的 IMP，在通过该类结构中的 super_class指针在其父类结构的方法列表中去查找，直到在某个父类的方法列表中找到对应的IMP，返回它，并加入cache中；<br>4、如果在自身以及所有父类的方法列表中都没有找到对应的 IMP，则看是不是可以进行动态方法决议；<br>5、如果动态方法决议没能解决问题，进入下面要讲的消息转发流程。</p>
<h1 id="消息转发机制"><a href="#消息转发机制" class="headerlink" title="消息转发机制"></a>消息转发机制</h1><p>对象在函数列表中找不到SEL或者找不到SEL对应的IMP实现的时候就会进入消息转发流程。流程如下：</p>
<p><img src="/img/objc_msg1.jpeg" alt="objc"></p>
<h2 id="BOOL-resolveInstanceMethod-SEL-sel-方法拦截消息"><a href="#BOOL-resolveInstanceMethod-SEL-sel-方法拦截消息" class="headerlink" title="+(BOOL)resolveInstanceMethod:(SEL)sel  方法拦截消息"></a>+(BOOL)resolveInstanceMethod:(SEL)sel  方法拦截消息</h2><p>这个消息拦截的作用在于给个机会给本对象动态添加需要的selector。<br>先来看个例子：</p>
<p>Fish类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;  </span><br><span class="line">@interface Fish : NSObject  </span><br><span class="line">-(void)fishDescribeYouSelf;  </span><br><span class="line">@end  </span><br><span class="line">  </span><br><span class="line">#import &quot;Fish.h&quot;  </span><br><span class="line">#import &lt;objc/message.h&gt;  </span><br><span class="line">@implementation Fish  </span><br><span class="line">-(void)fishDescribeYouSelf&#123;  </span><br><span class="line">    NSLog(@&quot;I am fish&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">-(void)_fishMethodNotExit&#123;  </span><br><span class="line">    NSLog(@&quot;_fishMethodNotExit&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">//查找动态指定的IMP  </span><br><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;  </span><br><span class="line">      </span><br><span class="line">    if (sel == NSSelectorFromString(@&quot;fishMethodNotExit&quot;)) &#123;  </span><br><span class="line">        IMP _fishMethodNotExit = [Fish instanceMethodForSelector:@selector(_fishMethodNotExit)];  </span><br><span class="line">        class_addMethod([self class], sel, _fishMethodNotExit, &quot;v@:&quot;);  //v@:  第一个字符代表返回的值是void，@是self的类型id，:是_cmd的类型SEL。（Objective-c中的方法默认被隐藏了两个参数：self指向对象本身,_cmd指向方法本身）。如果是@@:则代表返回值是字符串，f@:代表返回值是浮点型  </span><br><span class="line">        return YES;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    return [super resolveInstanceMethod:sel];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fish *fish = [[Fish alloc] init];  </span><br><span class="line">[fish fishMethodNotExit];</span><br></pre></td></tr></table></figure>
<p>程序不会崩溃并且输出：_fishMethodNotExit。找不到fishMethodNotExit的时候，系统调用了 resolveInstanceMethod，并且给找不到的SEL动态添加了IMP，使得调用_fishMethodNotExit这个函数。</p>
<p>resolveInstanceMethod:方法常常用来实现 @dynamic属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">id autoDictionaryGetter(id self,SEL _cmd);</span><br><span class="line">void autoDictionarySetter(id self, SEL _cmd, id value);</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector&#123;</span><br><span class="line">	NSString *selectorString = NSStringFromSelector(selector);</span><br><span class="line">	if ( /* selector is from a @dynamic property */ )&#123;</span><br><span class="line">		if ([selectorString hasPrefix:@&quot;set&quot;])&#123;</span><br><span class="line">			class_method(self,</span><br><span class="line">							selector,</span><br><span class="line">							(IMP)autoDictionarySetter,</span><br><span class="line">							&quot;v@:@&quot;);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			class_addMethod(self,</span><br><span class="line">							   selector,</span><br><span class="line">							   (IMP)autoDictionaryGetter,</span><br><span class="line">							   &quot;@@:&quot;</span><br><span class="line">								);</span><br><span class="line">		&#125;</span><br><span class="line">		return YES;</span><br><span class="line">	&#125;</span><br><span class="line">	return [super resolveInstanceMethod:selector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="备援接收者-id-forwardingTargetForSelector-SEL-aSelector"><a href="#备援接收者-id-forwardingTargetForSelector-SEL-aSelector" class="headerlink" title="备援接收者 -(id)forwardingTargetForSelector:(SEL)aSelector"></a>备援接收者 -(id)forwardingTargetForSelector:(SEL)aSelector</h2><p>没有在resolveInstanceMethod实现相关的动态添加，不管返回值是否为YES，消息都会来到快速转发forwardingTargetForSelector。<br>这个消息拦截的作用在于，给个机会把消息转发给另外一个对象<br>看例子，新增一个Flower类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;  </span><br><span class="line">  </span><br><span class="line">@interface Flower : NSObject  </span><br><span class="line">-(void)fishMethodNotExit;  </span><br><span class="line">@end  </span><br><span class="line">  </span><br><span class="line">@implementation Flower  </span><br><span class="line">-(void)fishMethodNotExit&#123;  </span><br><span class="line">    NSLog(@&quot;fishMethodNotExit in Flower&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>去掉Fish类的resolveInstanceMethod，添加forwardingTargetForSelector的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;  </span><br><span class="line">    Flower *flower = [[Flower alloc] init];  </span><br><span class="line">    if ([flower respondsToSelector:aSelector]) &#123;  </span><br><span class="line">        return flower;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    return self;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fish *fish = [[Fish alloc] init];  </span><br><span class="line">[fish fishMethodNotExit];</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fishMethodNotExit in Flower</span><br></pre></td></tr></table></figure>
<p>注意： 我们无法操作经由这一步所转发的消息。若是想在发送给备援接收者之前先修改消息内容，那就得通过完整的消息转发机制来做了。</p>
<h2 id="完整的消息转发-methodSignatureForSelector-forwardInvocation"><a href="#完整的消息转发-methodSignatureForSelector-forwardInvocation" class="headerlink" title="完整的消息转发 methodSignatureForSelector:   forwardInvocation:"></a>完整的消息转发 methodSignatureForSelector:   forwardInvocation:</h2><p>如果resolveInstanceMethod 和 forwardingTargetForSelector没有对消息进行处理，则来到标准转发。methodSignatureForSelector:的作用在于为另一个类实现的消息创建一个有效的方法签名，必须实现，并且返回不为空的methodSignature，否则会crash。forwardInvocation:将选择器转发给一个真正实现了该消息的对象。每一个对象都从NSObject类继承了forwardInvocation:方法，但在NSObject中，该方法只是简单的调用doesNotRecognizeSelector:，通过重写该方法你就可以利用forwardInvocation:将消息转发给其它对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@interface ForwardClass : NSObject </span><br><span class="line">-(void)doSomethingElse;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ForwardClass</span><br><span class="line"></span><br><span class="line">-(void)doSomethingElse</span><br><span class="line"> &#123;</span><br><span class="line">    NSLog(@&quot;doSomething was called on %@&quot;, [self class]);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface SomeClass : NSObject </span><br><span class="line">&#123;</span><br><span class="line">    id forwardClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)doSomething;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SomeClass</span><br><span class="line"></span><br><span class="line">-(id)init</span><br><span class="line"> &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        forwardClass = [ForwardClass new];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)doSomething</span><br><span class="line"> &#123;</span><br><span class="line">    NSLog(@&quot;doSomething was called on %@&quot;, [self class]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line"> &#123;</span><br><span class="line">    if (! forwardClass) &#123;</span><br><span class="line">        [self doesNotRecognizeSelector: [invocation selector]];</span><br><span class="line">    &#125;</span><br><span class="line">    [invocation invokeWithTarget: forwardClass];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSMethodSignature*)methodSignatureForSelector:(SEL)selector</span><br><span class="line"> &#123;</span><br><span class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:selector];</span><br><span class="line">    if (! signature) &#123;</span><br><span class="line">        //生成方法签名</span><br><span class="line">        signature = [forwardClass methodSignatureForSelector:selector];</span><br><span class="line">        //[NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;]; //也可以这样生成方法签名</span><br><span class="line">    &#125;</span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id someClass = [SomeClass new];</span><br><span class="line">  [someClass doSomething];//ForwardTest[1291:56187] doSomething was called on SomeClass</span><br><span class="line">  [someClass doSomethingElse];// ForwardTest[1291:56187] doSomething was called on ForwardClass</span><br></pre></td></tr></table></figure>
<h2 id="NSInvocation介绍"><a href="#NSInvocation介绍" class="headerlink" title="NSInvocation介绍"></a>NSInvocation介绍</h2><p>在iOS中用Objective-C框架可以直接调用某个对象的消息方式有2种，（另外当然可以直接调用objc_msgSend）<br>一种是performSelector:withObject: ，再一种就是NSInvocation 。<br>第一种方式比较简单，能完成简单的调用。但是对于<code>&gt;2个的参数或者有返回值</code>的处理，那就需要做些额外工作才能搞定。那么在这种情况下，我们就可以使用NSInvocation来进行这些相对复杂的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//方法签名类，需要被调用消息所属的类AsynInvoke ,被调用的消息invokeMethod:</span><br><span class="line">NSMethodSignature *sig= [[AsynInvoke class] instanceMethodSignatureForSelector:@selector(invokeMethod:)];</span><br><span class="line">//根据方法签名创建一个NSInvocation</span><br><span class="line">NSInvocation *invocation=[NSInvocation invocationWithMethodSignature:sig];</span><br><span class="line">//设置调用者也就是AsynInvoked的实例对象，在这里我用self替代</span><br><span class="line">[invocation setTarget:self];</span><br><span class="line">//设置被调用的消息</span><br><span class="line">[invocation setSelector:@selector(invokeMethod:)];</span><br><span class="line">//如果此消息有参数需要传入，那么就需要按照如下方法进行参数设置，需要注意的是，atIndex的下标必须从2开始。原因为：0 1 两个参数已经被target 和selector占用</span><br><span class="line">NSInteger num=10;</span><br><span class="line">[invocation setArgument:&amp;num atIndex:2];</span><br><span class="line">//retain 所有参数，防止参数被释放dealloc</span><br><span class="line">[invocation retainArguments];</span><br><span class="line">//消息调用</span><br><span class="line">[invocation invoke];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//如果调用的消息有返回值，那么可进行以下处理</span><br><span class="line">//获得返回值类型</span><br><span class="line">const char *returnType = sig.methodReturnType;</span><br><span class="line">//声明返回值变量</span><br><span class="line">id returnValue;</span><br><span class="line">//如果没有返回值，也就是消息声明为void，那么returnValue=nil</span><br><span class="line">if( !strcmp(returnType, @encode(void)) )&#123;</span><br><span class="line">	returnValue =  nil;</span><br><span class="line">&#125;</span><br><span class="line">//如果返回值为对象，那么为变量赋值</span><br><span class="line">else if( !strcmp(returnType, @encode(id)) )&#123;</span><br><span class="line">	[invocation getReturnValue:&amp;returnValue];</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">	//如果返回值为普通类型NSInteger  BOOL</span><br><span class="line">	//返回值长度</span><br><span class="line">	NSUInteger length = [sig methodReturnLength];</span><br><span class="line">	//根据长度申请内存</span><br><span class="line">	void *buffer = (void *)malloc(length);</span><br><span class="line">	//为变量赋值</span><br><span class="line">	[invocation getReturnValue:buffer];</span><br><span class="line"></span><br><span class="line">	if( !strcmp(returnType, @encode(BOOL)) ) &#123;</span><br><span class="line">		returnValue = [NSNumber numberWithBool:*((BOOL*)buffer)];</span><br><span class="line">	&#125;</span><br><span class="line">		else if( !strcmp(returnType, @encode(NSInteger)) )&#123;</span><br><span class="line">		returnValue = [NSNumber numberWithInteger:*((NSInteger*)buffer)];</span><br><span class="line">	&#125;</span><br><span class="line">	returnValue = [NSValue valueWithBytes:buffer objCType:returnType];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/Objective-C/">Objective-C</a><a href="/tags/Runtime/">Runtime</a></div><div class="post-nav"><a class="pre" href="/2015/11/25/runtime运用一、kvo实现原理/">runtime运用一、kvo实现原理</a><a class="next" href="/2015/11/17/Block的实现/">Block的实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/工具/">工具</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/">Objective-C</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/Runtime/">Runtime</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/设计模式/">设计模式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/UIKit/">UIKit</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/xx/">xx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/逆向/">逆向</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/opengl/">opengl</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/php/后端/">后端</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/jQuery/">jQuery</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/后端/redis/">redis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/后端/redis/缓存/">缓存</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像/">图像</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/Objective-C/" style="font-size: 15px;">Objective-C</a> <a href="/tags/图像/" style="font-size: 15px;">图像</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/后端/" style="font-size: 15px;">后端</a> <a href="/tags/搜索广告/" style="font-size: 15px;">搜索广告</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/xx/" style="font-size: 15px;">xx</a> <a href="/tags/Xcode/" style="font-size: 15px;">Xcode</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/视频编解码/" style="font-size: 15px;">视频编解码</a> <a href="/tags/图像质量/" style="font-size: 15px;">图像质量</a> <a href="/tags/打包/" style="font-size: 15px;">打包</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/javaScript/" style="font-size: 15px;">javaScript</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/逆向/" style="font-size: 15px;">逆向</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/加密/" style="font-size: 15px;">加密</a> <a href="/tags/计算机基础/" style="font-size: 15px;">计算机基础</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/UIKit/" style="font-size: 15px;">UIKit</a> <a href="/tags/xcode/" style="font-size: 15px;">xcode</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/Effective-Objective-C-2-0/" style="font-size: 15px;">Effective Objective-C 2.0</a> <a href="/tags/opengl/" style="font-size: 15px;">opengl</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/音视频/" style="font-size: 15px;">音视频</a> <a href="/tags/图片/" style="font-size: 15px;">图片</a> <a href="/tags/动画/" style="font-size: 15px;">动画</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/视频/" style="font-size: 15px;">视频</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/MVVM/" style="font-size: 15px;">MVVM</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/11/RGB与YUV格式转换/">RGB与YUV格式转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/01/颜色/">颜色</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/21/打印堆栈信息，保存现场/">打印堆栈信息，保存现场</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/22/mac-os开启php-Apache-MySQL环境搭建/">mac os开启php+Apache+MySQL环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/flv打包的h-264格式/">flv打包的h.264格式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/NSObject与id的区别/">NSObject与id的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/06/C-虚函数、纯虚函数/">C++虚函数、纯虚函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/22/xcode工程嵌入工程/">xcode工程嵌入工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/21/linux命令备忘-md/">linux命令备忘.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/09/cocoapod库制作/">cocoapod库制作</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">格物致知.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>