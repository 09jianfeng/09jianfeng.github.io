<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>RunLoop | 格物致知</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">RunLoop</h1><a id="logo" href="/.">格物致知</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">RunLoop</h1><div class="post-meta">Apr 13, 2015</div><div class="post-content"><h1 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop"></a>什么是RunLoop</h1><p>CFRunLoopRef 的代码是开源的，你可以在这里 <a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">http://opensource.apple.com/tarballs/CF/</a> 下载到整个 CoreFoundation 的源码来查看。 <a href="https://github.com/apple/swift-corelibs-foundation/" target="_blank" rel="noopener">https://github.com/apple/swift-corelibs-foundation/</a> 这个是swift版的开源。</p>
<p>命令式执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[])&#123;</span><br><span class="line">	NSLog(@&quot;hello world&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Event驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[])&#123;</span><br><span class="line">	while(AppIsRunning)&#123;</span><br><span class="line">		id whoWakesMe = SleepForWakingUp();</span><br><span class="line">		id event = GetEvent(whoWakesMe);</span><br><span class="line">		HandleEvent(event);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="run-Loop作用"><a href="#run-Loop作用" class="headerlink" title="run Loop作用"></a>run Loop作用</h2><p>RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>
<ul>
<li>使程序一直运行并接受用户输入</li>
<li>决定程序在何处应该处理哪些Event</li>
<li>调用解耦 (Message Queue)</li>
<li>节省CPU时间</li>
</ul>
<h2 id="Run-Loops、Cocoa、线程"><a href="#Run-Loops、Cocoa、线程" class="headerlink" title="Run Loops、Cocoa、线程"></a>Run Loops、Cocoa、线程</h2><p>层次架构</p>
<p>Foundation: NSRunLoop -&gt; 就是对CF层的一个封装</p>
<p>Core Foundation: CFRunLoop -&gt; 开源的，大概是3000行左右</p>
<p>System：GCD、mach kernel、block、pthread….</p>
<p>跟RunLoop关系比较大的一些</p>
<ul>
<li>NSTimer</li>
<li>UIEvent</li>
<li>AutoreleaseNSObject(NSDelayedPerforming)</li>
<li>NSObject(NSThreadPerformAddition)</li>
<li>CADisplayLink、CATransition（设置controller之间的转场动画）</li>
<li>CAAnimation</li>
<li>dispatch_get_main_queue()</li>
<li>NSURLConnection</li>
<li>AFNetworking</li>
</ul>
<p>主线程几乎所有函数都是从以下六个之一的函数调起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><br><span class="line">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><br></pre></td></tr></table></figure>
<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<h1 id="RunLoop-机制"><a href="#RunLoop-机制" class="headerlink" title="RunLoop 机制"></a>RunLoop 机制</h1><p>直接讲 Core Foundation层。</p>
<p><img src="../img/runloop1.png" alt="runloop1"></p>
<p>CFRunLoopMode是个非常重要的概念， 起决定性的作用就是下面的三个。CFRunloopSource、CFRunLoopTimer、CFRunLoopObserver。   runloop可以嵌套，要么就同时只有一个mode在跑。</p>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 </p>
<p> Source/Timer/Observer 被统称为 mode item，<strong>一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</strong></p>
<h2 id="RunLoop-Mode"><a href="#RunLoop-Mode" class="headerlink" title="RunLoop Mode"></a>RunLoop Mode</h2><p>RunLoop在同一段时间只能且必须在一种特定Mode下Run,更换Mode时,需要停止当前Loop,然后重启新Loop,Mode是iOS App滑动顺畅的关键 。（滑动的时候，会切掉mode，只跑滑动的mode）</p>
<ul>
<li>NSDefaultRunLoopMode  默认状态、空闲状态</li>
<li>UITrackingRunLoopMode 滑动ScrollView时的mode</li>
<li>UIInitializationRunLoopMode 私有，App启动时</li>
<li>NSRunLoopCommonModes Mode集合</li>
</ul>
<p><strong>NSRunLoopCommonModes</strong>：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p><strong>应用场景举例：</strong> 主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 如果希望在滑动的时候，也能调用到timer的回调，则只要把Timer加到NSRunLoopCommonModes，这样在滑动的时候也能调用到timer回调。</p>
<p><strong>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure>
<p><strong>Mode 暴露的管理 mode item 的接口有下面几个</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure>
<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h2 id="RunLoop-mode-item"><a href="#RunLoop-mode-item" class="headerlink" title="RunLoop mode item"></a>RunLoop mode item</h2><h3 id="CFRunLoopTimer"><a href="#CFRunLoopTimer" class="headerlink" title="CFRunLoopTimer"></a>CFRunLoopTimer</h3><p>它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p><img src="../img/runloop2.png" alt="runloop2"></p>
<h3 id="CFRunLoopSource"><a href="#CFRunLoopSource" class="headerlink" title="CFRunLoopSource"></a>CFRunLoopSource</h3><p>Source是RunLoop的数据源抽象类， RunLoop定义了两个Version的Source:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-&gt;1、Source0: </span><br><span class="line">处理App内部时间、App自己负责管理（触发），如UIEvent、CFSocket</span><br><span class="line"></span><br><span class="line">Source0 只包含了一个回调（函数指针，下图中的（void)(* perform）(void *info)，它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-&gt;2、Source1: </span><br><span class="line">由Runloop和内核管理,Mach port驱动，如CFMackPort、CFMessagePort</span><br><span class="line"></span><br><span class="line">Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程</span><br></pre></td></tr></table></figure>
<p><img src="../img/runloop3.png" alt="runloop3"></p>
<h3 id="CFRunLoopObserver"><a href="#CFRunLoopObserver" class="headerlink" title="CFRunLoopObserver"></a>CFRunLoopObserver</h3><p>是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<p><img src="../img/runloop4.png" alt="runloop4"></p>
<p>函数是<strong>CFRunLoopObserverCreateWithHandler</strong></p>
<p>CAAnimation应该是在beforWaiting或者afterWaiting后才调用，而不是调用了后就立即调用。会先收集一些animation的动作后，再一起执行。</p>
<h2 id="RunLoop的挂起与唤醒"><a href="#RunLoop的挂起与唤醒" class="headerlink" title="RunLoop的挂起与唤醒"></a>RunLoop的挂起与唤醒</h2><p><img src="../img/runloop8.png" alt="runloop8"></p>
<p>mach_msg_trap、mach_msg 是mac 内核的东西.__CFRunLoopServiceMachPort 发送一个消息,代表等待别人唤起的状态，这个runloop就被挂起。</p>
<ul>
<li>指定用于唤醒的mach_port端口</li>
<li>调用mach_msg监听唤醒端口，被唤醒前，系统内核将这个线程挂起，停留在mach_msg_trap状态</li>
<li>由另一个线程 （或另一个进程中的某个线程）向内核发送这个端口的msg后，trap状态被唤醒，RunLoop继续开始干活。</li>
</ul>
<h2 id="RunLoop迭代执行顺序"><a href="#RunLoop迭代执行顺序" class="headerlink" title="RunLoop迭代执行顺序"></a>RunLoop迭代执行顺序</h2><p><img src="../img/runloop9.png" alt="runloop9"></p>
<p>确切说是主线程上的RunLoop的执行顺序。</p>
<h2 id="RunLoopObserver-与-Autorelease-Pool"><a href="#RunLoopObserver-与-Autorelease-Pool" class="headerlink" title="RunLoopObserver 与 Autorelease Pool"></a>RunLoopObserver 与 Autorelease Pool</h2><p>Observer被触发的时候，调用的 Autorelease。  UIKit通过RunLoopObserver在RunLoop两次Sleep间对AutoreleasePool进行Pod和Push。将这次Loop中产生的Autorelease对象释放。 </p>
<p>子线程中的自动释放池的释放：每个线程创建的时候就会创建一个autorelease pool，并且在线程退出的时候，清空autorelease pool。所以子线程的autorelease对象，要么在子线程中设置runloop清楚</p>
<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">Autorelease原理</a> 关键点：一个以 AutoreleasePoolPage为节点的双向链表, 每个page是4096（虚拟内存一页的大小）。除了一些必要的字段占用的空间。剩下的空间用于存放需要释放的对象指针。放满了后再直线下一个链表</p>
<h2 id="CFRunLoopMode"><a href="#CFRunLoopMode" class="headerlink" title="CFRunLoopMode"></a>CFRunLoopMode</h2><p>RunLoop在同一段时间只能且必须在一种特定Mode下Run,更换Mode时,需要停止当前Loop,然后重启新Loop,Mode是iOS App滑动顺畅的关键 。（滑动的时候，会切掉mode，只跑滑动的mode）</p>
<ul>
<li>NSDefaultRunLoopMode  默认状态、空闲状态</li>
<li>UITrackingRunLoopMode 滑动ScrollView时的mode</li>
<li>UIInitializationRunLoopMode 私有，App启动时</li>
<li>NSRunLoopCommonModes Mode集合</li>
</ul>
<h2 id="UITrackingRunLoopMode-与-Timer"><a href="#UITrackingRunLoopMode-与-Timer" class="headerlink" title="UITrackingRunLoopMode 与 Timer"></a>UITrackingRunLoopMode 与 Timer</h2><p>timer跑在 NSDefaultRunLoopMode 的话，滑动ScrollView，会被暂停。</p>
<p><img src="../img/runloop5.png" alt="runloop5"></p>
<p>注意：子线程默认是没有创建runloop的，除非调用了Runloop相关的接口，才会生成。  </p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
<h2 id="RunLoopMode的切换"><a href="#RunLoopMode的切换" class="headerlink" title="RunLoopMode的切换"></a>RunLoopMode的切换</h2><p><img src="../img/runloop6.png" alt="runloop6"></p>
<p>可以看出在滑动的时候是运行在UITrackingRunLoopMode下的，这个时候是在跑 timer。</p>
<h2 id="RunLoop-与-dispatch-get-main-queue"><a href="#RunLoop-与-dispatch-get-main-queue" class="headerlink" title="RunLoop 与 dispatch_get_main_queue()"></a>RunLoop 与 dispatch_get_main_queue()</h2><p><img src="../img/runloop7.png" alt="runloop7"></p>
<p>queue如果是main queue的话，GCD就和runloop有关系。主要是因为大家获取的主线程是一样的。这里的关系，也就仅仅是用于runloop调起main queue的block。</p>
<h2 id="RunLoop的挂起与唤醒-1"><a href="#RunLoop的挂起与唤醒-1" class="headerlink" title="RunLoop的挂起与唤醒"></a>RunLoop的挂起与唤醒</h2><p><img src="../img/runloop8.png" alt="runloop8"></p>
<p>mach_msg_trap、mach_msg 是mac 内核的东西.__CFRunLoopServiceMachPort 发送一个消息,代表等待别人唤起的状态，这个runloop就被挂起。</p>
<ul>
<li>指定用于唤醒的mach_port端口</li>
<li>调用mach_msg监听唤醒端口，被唤醒前，系统内核将这个线程挂起，停留在mach_msg_trap状态</li>
<li>由另一个线程 （或另一个进程中的某个线程）向内核发送这个端口的msg后，trap状态被唤醒，RunLoop继续开始干活。</li>
</ul>
<h2 id="RunLoop迭代执行顺序-1"><a href="#RunLoop迭代执行顺序-1" class="headerlink" title="RunLoop迭代执行顺序"></a>RunLoop迭代执行顺序</h2><p><img src="../img/runloop9.png" alt="runloop9"></p>
<p>确切说是主线程上的RunLoop的执行顺序。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p><code>[runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]</code> 用于别让线程被销毁，一直等待这这个port。</p>
<p><img src="../img/runloop10.png" alt="runloop10"></p>
<p>加载图片的时候避免在滑动的模式下加载，以免卡住滑动。闲时再加载</p>
<p><img src="../img/runloop11.png" alt="runloop11"></p>
<h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p>
<p><img src="../img/runloop13.png" alt="runloop14"></p>
<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>
<h2 id="在AFNetWorking中应用"><a href="#在AFNetWorking中应用" class="headerlink" title="在AFNetWorking中应用"></a>在AFNetWorking中应用</h2><p>[runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]用于别让线程被销毁，一直等待这这个port。</p>
<p>AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>
<p><img src="../img/runloop10.png" alt="runloop10"></p>
<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if ([self isCancelled]) &#123;</span><br><span class="line">        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125; else if ([self isReady]) &#123;</span><br><span class="line">        self.state = AFOperationExecutingState;</span><br><span class="line">        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>
<h2 id="Async-Test-Case"><a href="#Async-Test-Case" class="headerlink" title="Async Test Case"></a>Async Test Case</h2><p>facebook的开源库，可以在后台进程异步创建 UIView、CALayer。在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p><a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="noopener">https://github.com/facebook/AsyncDisplayKit</a></p>
<p><img src="../img/runloop12.png" alt="runloop12"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="">iOS线下分享 孙源</a></p>
<p>深入理解RunLoop <a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">http://blog.ibireme.com/2015/05/18/runloop/</a></p>
<p>进程间通信，Mach ports <a href="https://segmentfault.com/a/1190000002400329" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002400329</a></p>
<p>runtime runloop <a href="http://www.jianshu.com/p/d87efbf427c5" target="_blank" rel="noopener">http://www.jianshu.com/p/d87efbf427c5</a></p>
</div><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/Objective-C/">Objective-C</a></div><div class="post-nav"><a class="pre" href="/2015/04/13/Cycript 注入测试函数/">Cycript 注入测试函数</a><a class="next" href="/2015/04/11/CydiaSubstrate 实践/">CydiaSubstrate 实践</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/工具/">工具</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/">Objective-C</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/Runtime/">Runtime</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/线程/">线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objective-C/设计模式/">设计模式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/UIKit/">UIKit</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/逆向/">逆向</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/opengl/">opengl</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/php/后端/">后端</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/jQuery/">jQuery</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/后端/redis/">redis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/后端/redis/缓存/">缓存</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/音视频/">音视频</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/Objective-C/" style="font-size: 15px;">Objective-C</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/后端/" style="font-size: 15px;">后端</a> <a href="/tags/搜索广告/" style="font-size: 15px;">搜索广告</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/Xcode/" style="font-size: 15px;">Xcode</a> <a href="/tags/音视频/" style="font-size: 15px;">音视频</a> <a href="/tags/打包/" style="font-size: 15px;">打包</a> <a href="/tags/xxxx/" style="font-size: 15px;">xxxx</a> <a href="/tags/图像/" style="font-size: 15px;">图像</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/javaScript/" style="font-size: 15px;">javaScript</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/逆向/" style="font-size: 15px;">逆向</a> <a href="/tags/opengl/" style="font-size: 15px;">opengl</a> <a href="/tags/metal/" style="font-size: 15px;">metal</a> <a href="/tags/openGL/" style="font-size: 15px;">openGL</a> <a href="/tags/加密/" style="font-size: 15px;">加密</a> <a href="/tags/计算机基础/" style="font-size: 15px;">计算机基础</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/UIKit/" style="font-size: 15px;">UIKit</a> <a href="/tags/xcode/" style="font-size: 15px;">xcode</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/Effective-Objective-C-2-0/" style="font-size: 15px;">Effective Objective-C 2.0</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/图片/" style="font-size: 15px;">图片</a> <a href="/tags/动画/" style="font-size: 15px;">动画</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/视频/" style="font-size: 15px;">视频</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/MVVM/" style="font-size: 15px;">MVVM</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/11/YUV介绍/">YUV格式介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/01/颜色/">颜色</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/21/打印堆栈信息，保存现场/">打印堆栈信息，保存现场</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/22/mac-os开启php-Apache-MySQL环境搭建/">mac os开启php+Apache+MySQL环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/flv打包的h-264格式/">flv打包的h.264格式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/NSObject与id的区别/">NSObject与id的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/06/C-虚函数、纯虚函数/">C++虚函数、纯虚函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/22/xcode工程嵌入工程/">xcode工程嵌入工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/21/linux命令备忘-md/">linux命令备忘.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/09/cocoapod库制作/">cocoapod库制作</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">格物致知.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>